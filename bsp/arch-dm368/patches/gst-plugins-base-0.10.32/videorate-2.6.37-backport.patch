Index: gst-plugins-base-0.10.32/src/gst/videorate/gstvideorate.c
===================================================================
--- gst-plugins-base-0.10.32.orig/src/gst/videorate/gstvideorate.c	2014-05-28 17:42:20.022256387 -0600
+++ gst-plugins-base-0.10.32/src/gst/videorate/gstvideorate.c	2014-05-28 17:42:21.630256373 -0600
@@ -86,17 +86,26 @@
 #define DEFAULT_SILENT          TRUE
 #define DEFAULT_NEW_PREF        1.0
 #define DEFAULT_SKIP_TO_FIRST   FALSE
+#define DEFAULT_DROP_ONLY       FALSE
+#define DEFAULT_AVERAGE_PERIOD  0
+#define DEFAULT_MAX_RATE        G_MAXINT
+#define DEFAULT_FORCE_FPS_N     -1
+#define DEFAULT_FORCE_FPS_D     1
 
 enum
 {
-  ARG_0,
-  ARG_IN,
-  ARG_OUT,
-  ARG_DUP,
-  ARG_DROP,
-  ARG_SILENT,
-  ARG_NEW_PREF,
-  ARG_SKIP_TO_FIRST
+  PROP_0,
+  PROP_IN,
+  PROP_OUT,
+  PROP_DUP,
+  PROP_DROP,
+  PROP_SILENT,
+  PROP_NEW_PREF,
+  PROP_SKIP_TO_FIRST,
+  PROP_DROP_ONLY,
+  PROP_AVERAGE_PERIOD,
+  PROP_MAX_RATE,
+  PROP_FORCE_FPS
       /* FILL ME */
 };
 
@@ -118,24 +127,39 @@
 
 static void gst_video_rate_swap_prev (GstVideoRate * videorate,
     GstBuffer * buffer, gint64 time);
-static gboolean gst_video_rate_event (GstPad * pad, GstEvent * event);
-static gboolean gst_video_rate_query (GstPad * pad, GstQuery * query);
-static GstFlowReturn gst_video_rate_chain (GstPad * pad, GstBuffer * buffer);
+static gboolean gst_video_rate_event (GstBaseTransform * trans,
+    GstEvent * event);
+static gboolean
+gst_video_rate_query (GstPad * pad, GstQuery * query);
+
+static gboolean gst_video_rate_setcaps (GstBaseTransform * trans,
+    GstCaps * in_caps, GstCaps * out_caps);
+
+static GstCaps *gst_video_rate_transform_caps (GstBaseTransform * trans,
+    GstPadDirection direction, GstCaps * caps);
+
+static void gst_video_rate_fixate_caps (GstBaseTransform * trans,
+    GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);
+
+static GstFlowReturn gst_video_rate_prepare_output_buffer (GstBaseTransform *
+    trans, GstBuffer * input, gint size, GstCaps * caps, GstBuffer ** buf);
+static GstFlowReturn gst_video_rate_transform_ip (GstBaseTransform * trans,
+    GstBuffer * buf);
+
+static gboolean gst_video_rate_start (GstBaseTransform * trans);
+static gboolean gst_video_rate_stop (GstBaseTransform * trans);
+
 
 static void gst_video_rate_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
 static void gst_video_rate_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec);
 
-static GstStateChangeReturn gst_video_rate_change_state (GstElement * element,
-    GstStateChange transition);
-
-/*static guint gst_video_rate_signals[LAST_SIGNAL] = { 0 }; */
-
 static GParamSpec *pspec_drop = NULL;
 static GParamSpec *pspec_duplicate = NULL;
 
-GST_BOILERPLATE (GstVideoRate, gst_video_rate, GstElement, GST_TYPE_ELEMENT);
+GST_BOILERPLATE (GstVideoRate, gst_video_rate,
+    GstBaseTransform, GST_TYPE_BASE_TRANSFORM);
 
 static void
 gst_video_rate_base_init (gpointer g_class)
@@ -157,32 +181,43 @@
 gst_video_rate_class_init (GstVideoRateClass * klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GstBaseTransformClass *base_class = GST_BASE_TRANSFORM_CLASS (klass);
 
   parent_class = g_type_class_peek_parent (klass);
 
   object_class->set_property = gst_video_rate_set_property;
   object_class->get_property = gst_video_rate_get_property;
 
-  g_object_class_install_property (object_class, ARG_IN,
+  base_class->set_caps = GST_DEBUG_FUNCPTR (gst_video_rate_setcaps);
+  base_class->transform_caps =
+      GST_DEBUG_FUNCPTR (gst_video_rate_transform_caps);
+  base_class->transform_ip = GST_DEBUG_FUNCPTR (gst_video_rate_transform_ip);
+  base_class->prepare_output_buffer =
+      GST_DEBUG_FUNCPTR (gst_video_rate_prepare_output_buffer);
+  base_class->event = GST_DEBUG_FUNCPTR (gst_video_rate_event);
+  base_class->start = GST_DEBUG_FUNCPTR (gst_video_rate_start);
+  base_class->stop = GST_DEBUG_FUNCPTR (gst_video_rate_stop);
+  base_class->fixate_caps = GST_DEBUG_FUNCPTR (gst_video_rate_fixate_caps);
+
+  g_object_class_install_property (object_class, PROP_IN,
       g_param_spec_uint64 ("in", "In",
           "Number of input frames", 0, G_MAXUINT64, 0,
           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (object_class, ARG_OUT,
+  g_object_class_install_property (object_class, PROP_OUT,
       g_param_spec_uint64 ("out", "Out", "Number of output frames", 0,
           G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
   pspec_duplicate = g_param_spec_uint64 ("duplicate", "Duplicate",
       "Number of duplicated frames", 0, G_MAXUINT64, 0,
       G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-  g_object_class_install_property (object_class, ARG_DUP, pspec_duplicate);
+  g_object_class_install_property (object_class, PROP_DUP, pspec_duplicate);
   pspec_drop = g_param_spec_uint64 ("drop", "Drop", "Number of dropped frames",
       0, G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
-  g_object_class_install_property (object_class, ARG_DROP, pspec_drop);
-  g_object_class_install_property (object_class, ARG_SILENT,
+  g_object_class_install_property (object_class, PROP_DROP, pspec_drop);
+  g_object_class_install_property (object_class, PROP_SILENT,
       g_param_spec_boolean ("silent", "silent",
           "Don't emit notify for dropped and duplicated frames", DEFAULT_SILENT,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-  g_object_class_install_property (object_class, ARG_NEW_PREF,
+  g_object_class_install_property (object_class, PROP_NEW_PREF,
       g_param_spec_double ("new-pref", "New Pref",
           "Value indicating how much to prefer new frames (unused)", 0.0, 1.0,
           DEFAULT_NEW_PREF, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
@@ -194,204 +229,331 @@
    *
    * Since: 0.10.25
    */
-  g_object_class_install_property (object_class, ARG_SKIP_TO_FIRST,
+  g_object_class_install_property (object_class, PROP_SKIP_TO_FIRST,
       g_param_spec_boolean ("skip-to-first", "Skip to first buffer",
           "Don't produce buffers before the first one we receive",
           DEFAULT_SKIP_TO_FIRST, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  element_class->change_state = GST_DEBUG_FUNCPTR (gst_video_rate_change_state);
-}
-
-/* return the caps that can be used on out_pad given in_caps on in_pad */
-static gboolean
-gst_video_rate_transformcaps (GstPad * in_pad, GstCaps * in_caps,
-    GstPad * out_pad, GstCaps ** out_caps)
-{
-  GstCaps *intersect;
-  const GstCaps *in_templ;
-  gint i;
-  GSList *extra_structures = NULL;
-  GSList *iter;
+  /**
+   * GstVideoRate:drop-only:
+   *
+   * Only drop frames, no duplicates are produced.
+   *
+   * Since: 0.10.36
+   */
+  g_object_class_install_property (object_class, PROP_DROP_ONLY,
+      g_param_spec_boolean ("drop-only", "Only Drop",
+          "Only drop frames, no duplicates are produced",
+          DEFAULT_DROP_ONLY, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  in_templ = gst_pad_get_pad_template_caps (in_pad);
-  intersect = gst_caps_intersect (in_caps, in_templ);
+  /**
+   * GstVideoRate:average-period:
+   *
+   * Arrange for maximum framerate by dropping frames beyond a certain framerate,
+   * where the framerate is calculated using a moving average over the
+   * configured.
+   *
+   * Since: 0.10.36
+   */
+  g_object_class_install_property (object_class, PROP_AVERAGE_PERIOD,
+      g_param_spec_uint64 ("average-period", "Period over which to average",
+          "Period over which to average the framerate (in ns) (0 = disabled)",
+          0, G_MAXINT64, DEFAULT_AVERAGE_PERIOD,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  /* all possible framerates are allowed */
-  for (i = 0; i < gst_caps_get_size (intersect); i++) {
-    GstStructure *structure;
+  /**
+   * GstVideoRate:max-rate:
+   *
+   * maximum framerate to pass through
+   *
+   * Since: 0.10.36
+   */
+  g_object_class_install_property (object_class, PROP_MAX_RATE,
+      g_param_spec_int ("max-rate", "maximum framerate",
+          "Maximum framerate allowed to pass through "
+          "(in frames per second, implies drop-only)",
+          1, G_MAXINT, DEFAULT_MAX_RATE,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 
-    structure = gst_caps_get_structure (intersect, i);
+  /**
+   * GstVideoRate:force-fps:
+   *
+   * Forced output framerate
+   *
+   * Since: 0.10.36
+   */
+  g_object_class_install_property (object_class, PROP_FORCE_FPS,
+      gst_param_spec_fraction ("force-fps", "Force output framerate",
+          "Force output framerate (negative means negotiate via caps)",
+          -1, 1, G_MAXINT, 1, DEFAULT_FORCE_FPS_N, DEFAULT_FORCE_FPS_D,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
+}
 
-    if (gst_structure_has_field (structure, "framerate")) {
-      GstStructure *copy_structure;
+static void
+gst_value_fraction_get_extremes (const GValue * v,
+    gint * min_num, gint * min_denom, gint * max_num, gint * max_denom)
+{
+  if (GST_VALUE_HOLDS_FRACTION (v)) {
+    *min_num = *max_num = gst_value_get_fraction_numerator (v);
+    *min_denom = *max_denom = gst_value_get_fraction_denominator (v);
+  } else if (GST_VALUE_HOLDS_FRACTION_RANGE (v)) {
+    const GValue *min, *max;
+
+    min = gst_value_get_fraction_range_min (v);
+    *min_num = gst_value_get_fraction_numerator (min);
+    *min_denom = gst_value_get_fraction_denominator (min);
+
+    max = gst_value_get_fraction_range_max (v);
+    *max_num = gst_value_get_fraction_numerator (max);
+    *max_denom = gst_value_get_fraction_denominator (max);
+  } else if (GST_VALUE_HOLDS_LIST (v)) {
+    gint min_n = G_MAXINT, min_d = 1, max_n = 0, max_d = 1;
+    int i, n;
+
+    *min_num = G_MAXINT;
+    *min_denom = 1;
+    *max_num = 0;
+    *max_denom = 1;
+
+    n = gst_value_list_get_size (v);
+
+    g_assert (n > 0);
+
+    for (i = 0; i < n; i++) {
+      const GValue *t = gst_value_list_get_value (v, i);
+
+      gst_value_fraction_get_extremes (t, &min_n, &min_d, &max_n, &max_d);
+      if (gst_util_fraction_compare (min_n, min_d, *min_num, *min_denom) < 0) {
+        *min_num = min_n;
+        *min_denom = min_d;
+      }
 
-      copy_structure = gst_structure_copy (structure);
-      gst_structure_set (copy_structure,
-          "framerate", GST_TYPE_FRACTION_RANGE, 0, 1, G_MAXINT, 1, NULL);
-      extra_structures = g_slist_append (extra_structures, copy_structure);
+      if (gst_util_fraction_compare (max_n, max_d, *max_num, *max_denom) > 0) {
+        *max_num = max_n;
+        *max_denom = max_d;
+      }
     }
+  } else {
+    g_warning ("Unknown type for framerate");
+    *min_num = 0;
+    *min_denom = 1;
+    *max_num = G_MAXINT;
+    *max_denom = 1;
   }
+}
 
-  /* append the extra structures */
-  for (iter = extra_structures; iter != NULL; iter = g_slist_next (iter)) {
-    gst_caps_append_structure (intersect, (GstStructure *) iter->data);
-  }
-  g_slist_free (extra_structures);
+/* Clamp the framerate in a caps structure to be a smaller range then
+ * [1...max_rate], otherwise return false */
+static gboolean
+gst_video_max_rate_clamp_structure (GstStructure * s, gint maxrate,
+    gint * min_num, gint * min_denom, gint * max_num, gint * max_denom)
+{
+  gboolean ret = FALSE;
 
-  *out_caps = intersect;
+  if (!gst_structure_has_field (s, "framerate")) {
+    /* No framerate field implies any framerate, clamping would result in
+     * [1..max_rate] so not a real subset */
+    goto out;
+  } else {
+    const GValue *v;
+    GValue intersection = { 0, };
+    GValue clamp = { 0, };
+    gint tmp_num, tmp_denom;
+
+    g_value_init (&clamp, GST_TYPE_FRACTION_RANGE);
+    gst_value_set_fraction_range_full (&clamp, 0, 1, maxrate, 1);
+
+    v = gst_structure_get_value (s, "framerate");
+    ret = gst_value_intersect (&intersection, v, &clamp);
+    g_value_unset (&clamp);
+
+    if (!ret)
+      goto out;
+
+    gst_value_fraction_get_extremes (&intersection,
+        min_num, min_denom, max_num, max_denom);
+
+    gst_value_fraction_get_extremes (v,
+        &tmp_num, &tmp_denom, max_num, max_denom);
+
+    if (gst_util_fraction_compare (*max_num, *max_denom, maxrate, 1) > 0) {
+      *max_num = maxrate;
+      *max_denom = 1;
+    }
 
-  return TRUE;
+    gst_structure_take_value (s, "framerate", &intersection);
+  }
+
+out:
+  return ret;
 }
 
 static GstCaps *
-gst_video_rate_getcaps (GstPad * pad)
+gst_video_rate_transform_caps (GstBaseTransform * trans,
+    GstPadDirection direction, GstCaps * caps)
 {
-  GstVideoRate *videorate;
-  GstPad *otherpad;
-  GstCaps *caps;
-
-  videorate = GST_VIDEO_RATE (GST_PAD_PARENT (pad));
+  GstVideoRate *videorate = GST_VIDEO_RATE (trans);
+  GstCaps *ret;
+  GstStructure *s, *s2;
+  GstStructure *s3 = NULL;
+  int maxrate = g_atomic_int_get (&videorate->max_rate);
+
+  /* Should always be called with simple caps */
+  g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), NULL);
+
+  ret = gst_caps_copy (caps);
+
+  s = gst_caps_get_structure (ret, 0);
+  s2 = gst_structure_copy (s);
+
+  if (videorate->force_fps_n >= 0 && videorate->force_fps_d >= 0) {
+    if (direction == GST_PAD_SINK) {
+      gst_caps_remove_structure (ret, 0);
+      gst_structure_set (s2, "framerate", GST_TYPE_FRACTION,
+          videorate->force_fps_n, videorate->force_fps_d, NULL);
+    } else {
+      gst_structure_set (s2, "framerate", GST_TYPE_FRACTION_RANGE, 0, 1,
+          G_MAXINT, 1, NULL);
+    }
+  } else if (videorate->drop_only) {
+    gint min_num = 0, min_denom = 1;
+    gint max_num = G_MAXINT, max_denom = 1;
+
+    /* Clamp the caps to our maximum rate as the first caps if possible */
+    if (!gst_video_max_rate_clamp_structure (s, maxrate,
+            &min_num, &min_denom, &max_num, &max_denom)) {
+      min_num = 0;
+      min_denom = 1;
+      max_num = maxrate;
+      max_denom = 1;
+
+      /* clamp wouldn't be a real subset of 1..maxrate, in this case the sink
+       * caps should become [1..maxrate], [1..maxint] and the src caps just
+       * [1..maxrate].  In case there was a caps incompatibility things will
+       * explode later as appropriate :)
+       *
+       * In case [X..maxrate] == [X..maxint], skip as we'll set it later
+       */
+      if (direction == GST_PAD_SRC && maxrate != G_MAXINT)
+        gst_structure_set (s, "framerate", GST_TYPE_FRACTION_RANGE,
+            min_num, min_denom, maxrate, 1, NULL);
+      else
+        gst_caps_remove_structure (ret, 0);
+    }
 
-  otherpad = (pad == videorate->srcpad) ? videorate->sinkpad :
-      videorate->srcpad;
+    if (direction == GST_PAD_SRC) {
+      /* We can accept anything as long as it's at least the minimal framerate
+       * the the sink needs */
+      gst_structure_set (s2, "framerate", GST_TYPE_FRACTION_RANGE,
+          min_num, min_denom, G_MAXINT, 1, NULL);
+
+      /* Also allow unknown framerate, if it isn't already */
+      if (min_num != 0 || min_denom != 1) {
+        s3 = gst_structure_copy (s);
+        gst_structure_set (s3, "framerate", GST_TYPE_FRACTION, 0, 1, NULL);
+      }
+    } else if (max_num != 0 || max_denom != 1) {
+      /* We can provide everything upto the maximum framerate at the src */
+      gst_structure_set (s2, "framerate", GST_TYPE_FRACTION_RANGE,
+          0, 1, max_num, max_denom, NULL);
+    }
+  } else if (direction == GST_PAD_SINK) {
+    gint min_num = 0, min_denom = 1;
+    gint max_num = G_MAXINT, max_denom = 1;
+
+    if (!gst_video_max_rate_clamp_structure (s, maxrate,
+            &min_num, &min_denom, &max_num, &max_denom))
+      gst_caps_remove_structure (ret, 0);
 
-  /* we can do what the peer can */
-  caps = gst_pad_peer_get_caps (otherpad);
-  if (caps) {
-    GstCaps *transform;
-
-    gst_video_rate_transformcaps (otherpad, caps, pad, &transform);
-    gst_caps_unref (caps);
-    caps = transform;
+    gst_structure_set (s2, "framerate", GST_TYPE_FRACTION_RANGE, 0, 1,
+        maxrate, 1, NULL);
   } else {
-    /* no peer, our padtemplate is enough then */
-    caps = gst_caps_copy (gst_pad_get_pad_template_caps (pad));
+    /* set the framerate as a range */
+    gst_structure_set (s2, "framerate", GST_TYPE_FRACTION_RANGE, 0, 1,
+        G_MAXINT, 1, NULL);
   }
 
-  return caps;
+  gst_caps_merge_structure (ret, s2);
+  if (s3 != NULL)
+    gst_caps_merge_structure (ret, s3);
+
+  return ret;
+}
+
+static void
+gst_video_rate_fixate_caps (GstBaseTransform * trans,
+    GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)
+{
+  GstStructure *s;
+  gint num, denom;
+
+  s = gst_caps_get_structure (caps, 0);
+  if (G_UNLIKELY (!gst_structure_get_fraction (s, "framerate", &num, &denom)))
+    return;
+
+  s = gst_caps_get_structure (othercaps, 0);
+  gst_structure_fixate_field_nearest_fraction (s, "framerate", num, denom);
 }
 
 static gboolean
-gst_video_rate_setcaps (GstPad * pad, GstCaps * caps)
+gst_video_rate_setcaps (GstBaseTransform * trans, GstCaps * in_caps,
+    GstCaps * out_caps)
 {
   GstVideoRate *videorate;
   GstStructure *structure;
   gboolean ret = TRUE;
-  GstPad *otherpad, *opeer;
   gint rate_numerator, rate_denominator;
 
-  videorate = GST_VIDEO_RATE (gst_pad_get_parent (pad));
+  videorate = GST_VIDEO_RATE (trans);
 
-  GST_DEBUG_OBJECT (pad, "setcaps called %" GST_PTR_FORMAT, caps);
+  GST_DEBUG_OBJECT (trans, "setcaps called in: %" GST_PTR_FORMAT
+      " out: %" GST_PTR_FORMAT, in_caps, out_caps);
 
-  structure = gst_caps_get_structure (caps, 0);
+  structure = gst_caps_get_structure (in_caps, 0);
   if (!gst_structure_get_fraction (structure, "framerate",
           &rate_numerator, &rate_denominator))
     goto no_framerate;
 
-  if (pad == videorate->srcpad) {
-    /* out_frame_count is scaled by the frame rate caps when calculating next_ts.
-     * when the frame rate caps change, we must update base_ts and reset
-     * out_frame_count */
-    if (videorate->to_rate_numerator) {
-      videorate->base_ts +=
-          gst_util_uint64_scale (videorate->out_frame_count,
-          videorate->to_rate_denominator * GST_SECOND,
-          videorate->to_rate_numerator);
-    }
-    videorate->out_frame_count = 0;
-    videorate->to_rate_numerator = rate_numerator;
-    videorate->to_rate_denominator = rate_denominator;
-    otherpad = videorate->sinkpad;
-  } else {
-    videorate->from_rate_numerator = rate_numerator;
-    videorate->from_rate_denominator = rate_denominator;
-    otherpad = videorate->srcpad;
-  }
-
-  /* now try to find something for the peer */
-  opeer = gst_pad_get_peer (otherpad);
-  if (opeer) {
-    if (gst_pad_accept_caps (opeer, caps)) {
-      /* the peer accepts the caps as they are */
-      gst_pad_set_caps (otherpad, caps);
-
-      ret = TRUE;
-    } else {
-      GstCaps *peercaps;
-      GstCaps *transform = NULL;
-
-      ret = FALSE;
-
-      /* see how we can transform the input caps */
-      if (!gst_video_rate_transformcaps (pad, caps, otherpad, &transform))
-        goto no_transform;
-
-      /* see what the peer can do */
-      peercaps = gst_pad_get_caps (opeer);
-
-      GST_DEBUG_OBJECT (opeer, "icaps %" GST_PTR_FORMAT, peercaps);
-      GST_DEBUG_OBJECT (videorate, "transform %" GST_PTR_FORMAT, transform);
-
-      /* filter against our possibilities */
-      caps = gst_caps_intersect (peercaps, transform);
-      gst_caps_unref (peercaps);
-      gst_caps_unref (transform);
-
-      GST_DEBUG_OBJECT (videorate, "intersect %" GST_PTR_FORMAT, caps);
-
-      /* take first possibility */
-      gst_caps_truncate (caps);
-      structure = gst_caps_get_structure (caps, 0);
+  videorate->from_rate_numerator = rate_numerator;
+  videorate->from_rate_denominator = rate_denominator;
 
-      /* and fixate */
-      gst_structure_fixate_field_nearest_fraction (structure, "framerate",
-          rate_numerator, rate_denominator);
+  structure = gst_caps_get_structure (out_caps, 0);
+  if (!gst_structure_get_fraction (structure, "framerate",
+          &rate_numerator, &rate_denominator))
+    goto no_framerate;
 
-      gst_structure_get_fraction (structure, "framerate",
-          &rate_numerator, &rate_denominator);
+  /* out_frame_count is scaled by the frame rate caps when calculating next_ts.
+   * when the frame rate caps change, we must update base_ts and reset
+   * out_frame_count */
+  if (videorate->to_rate_numerator) {
+    videorate->base_ts +=
+        gst_util_uint64_scale (videorate->out_frame_count,
+        videorate->to_rate_denominator * GST_SECOND,
+        videorate->to_rate_numerator);
+  }
+  videorate->out_frame_count = 0;
+  videorate->to_rate_numerator = rate_numerator;
+  videorate->to_rate_denominator = rate_denominator;
 
-      if (otherpad == videorate->srcpad) {
-        videorate->to_rate_numerator = rate_numerator;
-        videorate->to_rate_denominator = rate_denominator;
-      } else {
-        videorate->from_rate_numerator = rate_numerator;
-        videorate->from_rate_denominator = rate_denominator;
-      }
+  if (rate_numerator)
+    videorate->wanted_diff = gst_util_uint64_scale_int (GST_SECOND,
+        rate_denominator, rate_numerator);
+  else
+    videorate->wanted_diff = 0;
 
-      if (gst_structure_has_field (structure, "interlaced"))
-        gst_structure_fixate_field_boolean (structure, "interlaced", FALSE);
-      if (gst_structure_has_field (structure, "color-matrix"))
-        gst_structure_fixate_field_string (structure, "color-matrix", "sdtv");
-      if (gst_structure_has_field (structure, "chroma-site"))
-        gst_structure_fixate_field_string (structure, "chroma-site", "mpeg2");
-      if (gst_structure_has_field (structure, "pixel-aspect-ratio"))
-        gst_structure_fixate_field_nearest_fraction (structure,
-            "pixel-aspect-ratio", 1, 1);
-
-      gst_pad_set_caps (otherpad, caps);
-      gst_caps_unref (caps);
-      ret = TRUE;
-    }
-    gst_object_unref (opeer);
-  }
 done:
   /* After a setcaps, our caps may have changed. In that case, we can't use
    * the old buffer, if there was one (it might have different dimensions) */
   GST_DEBUG_OBJECT (videorate, "swapping old buffers");
   gst_video_rate_swap_prev (videorate, NULL, GST_CLOCK_TIME_NONE);
+  videorate->last_ts = GST_CLOCK_TIME_NONE;
+  videorate->average = 0;
 
-  gst_object_unref (videorate);
   return ret;
 
 no_framerate:
   {
     GST_DEBUG_OBJECT (videorate, "no framerate specified");
-    goto done;
-  }
-no_transform:
-  {
-    GST_DEBUG_OBJECT (videorate, "no framerate transform possible");
     ret = FALSE;
     goto done;
   }
@@ -411,6 +573,7 @@
   videorate->next_ts = GST_CLOCK_TIME_NONE;
   videorate->last_ts = GST_CLOCK_TIME_NONE;
   videorate->discont = TRUE;
+  videorate->average = 0;
   gst_video_rate_swap_prev (videorate, NULL, 0);
 
   gst_segment_init (&videorate->segment, GST_FORMAT_TIME);
@@ -419,36 +582,25 @@
 static void
 gst_video_rate_init (GstVideoRate * videorate, GstVideoRateClass * klass)
 {
-  videorate->sinkpad =
-      gst_pad_new_from_static_template (&gst_video_rate_sink_template, "sink");
-  gst_pad_set_event_function (videorate->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_event));
-  gst_pad_set_chain_function (videorate->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_chain));
-  gst_pad_set_getcaps_function (videorate->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_getcaps));
-  gst_pad_set_setcaps_function (videorate->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_setcaps));
-  gst_element_add_pad (GST_ELEMENT (videorate), videorate->sinkpad);
-
-  videorate->srcpad =
-      gst_pad_new_from_static_template (&gst_video_rate_src_template, "src");
-  gst_pad_set_query_function (videorate->srcpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_query));
-  gst_pad_set_getcaps_function (videorate->srcpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_getcaps));
-  gst_pad_set_setcaps_function (videorate->srcpad,
-      GST_DEBUG_FUNCPTR (gst_video_rate_setcaps));
-  gst_element_add_pad (GST_ELEMENT (videorate), videorate->srcpad);
-
   gst_video_rate_reset (videorate);
   videorate->silent = DEFAULT_SILENT;
   videorate->new_pref = DEFAULT_NEW_PREF;
+  videorate->drop_only = DEFAULT_DROP_ONLY;
+  videorate->average_period = DEFAULT_AVERAGE_PERIOD;
+  videorate->average_period_set = DEFAULT_AVERAGE_PERIOD;
+  videorate->max_rate = DEFAULT_MAX_RATE;
+  videorate->force_fps_n = DEFAULT_FORCE_FPS_N;
+  videorate->force_fps_d = DEFAULT_FORCE_FPS_D;
 
   videorate->from_rate_numerator = 0;
   videorate->from_rate_denominator = 0;
   videorate->to_rate_numerator = 0;
   videorate->to_rate_denominator = 0;
+
+  gst_base_transform_set_gap_aware (GST_BASE_TRANSFORM (videorate), TRUE);
+
+  gst_pad_set_query_function (GST_BASE_TRANSFORM_SRC_PAD (videorate),
+      GST_DEBUG_FUNCPTR (gst_video_rate_query));
 }
 
 /* flush the oldest buffer */
@@ -495,16 +647,17 @@
     GST_BUFFER_DURATION (outbuf) = videorate->next_ts - push_ts;
   }
 
-  /* adapt for looping, bring back to time in current segment. */
-  GST_BUFFER_TIMESTAMP (outbuf) = push_ts - videorate->segment.accum;
-
-  gst_buffer_set_caps (outbuf, GST_PAD_CAPS (videorate->srcpad));
+  /* We do not need to update time in VFR (variable frame rate) mode */
+  if (!videorate->drop_only) {
+    /* adapt for looping, bring back to time in current segment. */
+    GST_BUFFER_TIMESTAMP (outbuf) = push_ts - videorate->segment.accum;
+  }
 
   GST_LOG_OBJECT (videorate,
       "old is best, dup, pushing buffer outgoing ts %" GST_TIME_FORMAT,
       GST_TIME_ARGS (push_ts));
 
-  res = gst_pad_push (videorate->srcpad, outbuf);
+  res = gst_pad_push (GST_BASE_TRANSFORM_SRC_PAD (videorate), outbuf);
 
   return res;
 
@@ -523,7 +676,7 @@
   GST_LOG_OBJECT (videorate, "swap_prev: storing buffer %p in prev", buffer);
   if (videorate->prevbuf)
     gst_buffer_unref (videorate->prevbuf);
-  videorate->prevbuf = buffer;
+  videorate->prevbuf = buffer != NULL ? gst_buffer_ref (buffer) : NULL;
   videorate->prev_ts = time;
 }
 
@@ -549,12 +702,11 @@
 
 #define MAGIC_LIMIT  25
 static gboolean
-gst_video_rate_event (GstPad * pad, GstEvent * event)
+gst_video_rate_event (GstBaseTransform * trans, GstEvent * event)
 {
   GstVideoRate *videorate;
-  gboolean ret;
 
-  videorate = GST_VIDEO_RATE (gst_pad_get_parent (pad));
+  videorate = GST_VIDEO_RATE (trans);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_NEWSEGMENT:
@@ -671,21 +823,14 @@
       break;
   }
 
-  ret = gst_pad_push_event (videorate->srcpad, event);
-
-done:
-  gst_object_unref (videorate);
-
-  return ret;
+  return TRUE;
 
   /* ERRORS */
 format_error:
   {
     GST_WARNING_OBJECT (videorate,
         "Got segment but doesn't have GST_FORMAT_TIME value");
-    gst_event_unref (event);
-    ret = FALSE;
-    goto done;
+    return FALSE;
   }
 }
 
@@ -705,7 +850,7 @@
       guint64 latency;
       GstPad *peer;
 
-      if ((peer = gst_pad_get_peer (videorate->sinkpad))) {
+      if ((peer = gst_pad_get_peer (GST_BASE_TRANSFORM_SINK_PAD(videorate)))) {
         if ((res = gst_pad_query (peer, query))) {
           gst_query_parse_latency (query, &live, &min, &max);
 
@@ -752,19 +897,120 @@
 }
 
 static GstFlowReturn
-gst_video_rate_chain (GstPad * pad, GstBuffer * buffer)
+gst_video_rate_trans_ip_max_avg (GstVideoRate * videorate, GstBuffer * buf)
+{
+  GstClockTime ts = GST_BUFFER_TIMESTAMP (buf);
+
+  videorate->in++;
+
+  if (!GST_CLOCK_TIME_IS_VALID (ts) || videorate->wanted_diff == 0)
+    goto push;
+
+  /* drop frames if they exceed our output rate */
+  if (GST_CLOCK_TIME_IS_VALID (videorate->last_ts)) {
+    GstClockTimeDiff diff = ts - videorate->last_ts;
+
+    /* Drop buffer if its early compared to the desired frame rate and
+     * the current average is higher than the desired average
+     */
+    if (diff < videorate->wanted_diff &&
+        videorate->average < videorate->wanted_diff)
+      goto drop;
+
+    /* Update average */
+    if (videorate->average) {
+      GstClockTimeDiff wanted_diff;
+
+      if (G_LIKELY (videorate->average_period > videorate->wanted_diff))
+        wanted_diff = videorate->wanted_diff;
+      else
+        wanted_diff = videorate->average_period * 10;
+
+      videorate->average =
+          gst_util_uint64_scale_round (videorate->average,
+          videorate->average_period - wanted_diff,
+          videorate->average_period) +
+          gst_util_uint64_scale_round (diff, wanted_diff,
+          videorate->average_period);
+    } else {
+      videorate->average = diff;
+    }
+  }
+
+  videorate->last_ts = ts;
+
+push:
+  videorate->out++;
+  return GST_FLOW_OK;
+
+drop:
+  if (!videorate->silent)
+    gst_video_rate_notify_drop (videorate);
+  return GST_BASE_TRANSFORM_FLOW_DROPPED;
+}
+
+static GstFlowReturn
+gst_video_rate_prepare_output_buffer (GstBaseTransform * trans,
+    GstBuffer * input, gint size, GstCaps * caps, GstBuffer ** buf)
+{
+  if (gst_buffer_is_metadata_writable (input)) {
+    gst_buffer_set_caps (input, caps);
+    *buf = gst_buffer_ref (input);
+  } else {
+    *buf = gst_buffer_create_sub (input, 0, GST_BUFFER_SIZE (input));
+    gst_buffer_set_caps (*buf, caps);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_video_rate_transform_ip (GstBaseTransform * trans, GstBuffer * buffer)
 {
   GstVideoRate *videorate;
-  GstFlowReturn res = GST_FLOW_OK;
+  GstFlowReturn res = GST_BASE_TRANSFORM_FLOW_DROPPED;
   GstClockTime intime, in_ts, in_dur;
+  GstClockTime avg_period;
+  gboolean skip = FALSE;
 
-  videorate = GST_VIDEO_RATE (GST_PAD_PARENT (pad));
+  videorate = GST_VIDEO_RATE (trans);
 
   /* make sure the denominators are not 0 */
   if (videorate->from_rate_denominator == 0 ||
       videorate->to_rate_denominator == 0)
     goto not_negotiated;
 
+  GST_OBJECT_LOCK (videorate);
+  avg_period = videorate->average_period_set;
+  GST_OBJECT_UNLOCK (videorate);
+
+  /* MT-safe switching between modes */
+  if (G_UNLIKELY (avg_period != videorate->average_period)) {
+    gboolean switch_mode = (avg_period == 0 || videorate->average_period == 0);
+    videorate->average_period = avg_period;
+    videorate->last_ts = GST_CLOCK_TIME_NONE;
+
+    if (switch_mode) {
+      if (avg_period) {
+        /* enabling average mode */
+        videorate->average = 0;
+        /* make sure no cached buffers from regular mode are left */
+        gst_video_rate_swap_prev (videorate, NULL, 0);
+      } else {
+        /* enable regular mode */
+        videorate->next_ts = GST_CLOCK_TIME_NONE;
+        skip = TRUE;
+      }
+
+      /* max averaging mode has a no latency, normal mode does */
+      gst_element_post_message (GST_ELEMENT (videorate),
+          gst_message_new_latency (GST_OBJECT (videorate)));
+    }
+  }
+
+  if (videorate->average_period > 0)
+    return gst_video_rate_trans_ip_max_avg (videorate, buffer);
+
   in_ts = GST_BUFFER_TIMESTAMP (buffer);
   in_dur = GST_BUFFER_DURATION (buffer);
 
@@ -794,12 +1040,10 @@
     if (!GST_CLOCK_TIME_IS_VALID (videorate->next_ts)) {
       /* new buffer, we expect to output a buffer that matches the first
        * timestamp in the segment */
-      if (videorate->skip_to_first) {
-        videorate->next_ts = in_ts;
-        videorate->out_frame_count = gst_util_uint64_scale (in_ts,
-            videorate->to_rate_numerator,
-            videorate->to_rate_denominator * GST_SECOND) -
-            (videorate->segment.accum + videorate->segment.start);
+      if (videorate->skip_to_first || skip) {
+        videorate->next_ts = intime;
+        videorate->base_ts = in_ts - videorate->segment.start;
+        videorate->out_frame_count = 0;
       } else {
         videorate->next_ts =
             videorate->segment.start + videorate->segment.accum;
@@ -829,7 +1073,6 @@
       videorate->drop++;
       if (!videorate->silent)
         gst_video_rate_notify_drop (videorate);
-      gst_buffer_unref (buffer);
       goto done;
     }
 
@@ -853,16 +1096,20 @@
 
       /* output first one when its the best */
       if (diff1 <= diff2) {
+        GstFlowReturn r;
         count++;
 
         /* on error the _flush function posted a warning already */
-        if ((res =
-                gst_video_rate_flush_prev (videorate,
+        if ((r = gst_video_rate_flush_prev (videorate,
                     count > 1)) != GST_FLOW_OK) {
-          gst_buffer_unref (buffer);
+          res = r;
           goto done;
         }
       }
+
+      /* Do not produce any dups. We can exit loop now */
+      if (videorate->drop_only)
+        break;
       /* continue while the first one was the best, if they were equal avoid
        * going into an infinite loop */
     }
@@ -903,7 +1150,6 @@
 not_negotiated:
   {
     GST_WARNING_OBJECT (videorate, "no framerate negotiated");
-    gst_buffer_unref (buffer);
     res = GST_FLOW_NOT_NEGOTIATED;
     goto done;
   }
@@ -912,31 +1158,68 @@
   {
     GST_WARNING_OBJECT (videorate,
         "Got buffer with GST_CLOCK_TIME_NONE timestamp, discarding it");
-    gst_buffer_unref (buffer);
+    res = GST_BASE_TRANSFORM_FLOW_DROPPED;
     goto done;
   }
 }
 
+static gboolean
+gst_video_rate_start (GstBaseTransform * trans)
+{
+  gst_video_rate_reset (GST_VIDEO_RATE (trans));
+  return TRUE;
+}
+
+static gboolean
+gst_video_rate_stop (GstBaseTransform * trans)
+{
+  gst_video_rate_reset (GST_VIDEO_RATE (trans));
+  return TRUE;
+}
+
 static void
 gst_video_rate_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
   GstVideoRate *videorate = GST_VIDEO_RATE (object);
 
+  GST_OBJECT_LOCK (videorate);
   switch (prop_id) {
-    case ARG_SILENT:
+    case PROP_SILENT:
       videorate->silent = g_value_get_boolean (value);
       break;
-    case ARG_NEW_PREF:
+    case PROP_NEW_PREF:
       videorate->new_pref = g_value_get_double (value);
       break;
-    case ARG_SKIP_TO_FIRST:
+    case PROP_SKIP_TO_FIRST:
       videorate->skip_to_first = g_value_get_boolean (value);
       break;
+    case PROP_DROP_ONLY:
+      videorate->drop_only = g_value_get_boolean (value);
+      goto reconfigure;
+      break;
+    case PROP_AVERAGE_PERIOD:
+      videorate->average_period_set = g_value_get_uint64 (value);
+      break;
+    case PROP_MAX_RATE:
+      g_atomic_int_set (&videorate->max_rate, g_value_get_int (value));
+      goto reconfigure;
+      break;
+    case PROP_FORCE_FPS:
+      videorate->force_fps_n = gst_value_get_fraction_numerator (value);
+      videorate->force_fps_d = gst_value_get_fraction_denominator (value);
+      goto reconfigure;
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
+  GST_OBJECT_UNLOCK (videorate);
+  return;
+
+reconfigure:
+  GST_OBJECT_UNLOCK (videorate);
+  gst_base_transform_reconfigure (GST_BASE_TRANSFORM (videorate));
 }
 
 static void
@@ -945,62 +1228,47 @@
 {
   GstVideoRate *videorate = GST_VIDEO_RATE (object);
 
+  GST_OBJECT_LOCK (videorate);
   switch (prop_id) {
-    case ARG_IN:
+    case PROP_IN:
       g_value_set_uint64 (value, videorate->in);
       break;
-    case ARG_OUT:
+    case PROP_OUT:
       g_value_set_uint64 (value, videorate->out);
       break;
-    case ARG_DUP:
+    case PROP_DUP:
       g_value_set_uint64 (value, videorate->dup);
       break;
-    case ARG_DROP:
+    case PROP_DROP:
       g_value_set_uint64 (value, videorate->drop);
       break;
-    case ARG_SILENT:
+    case PROP_SILENT:
       g_value_set_boolean (value, videorate->silent);
       break;
-    case ARG_NEW_PREF:
+    case PROP_NEW_PREF:
       g_value_set_double (value, videorate->new_pref);
       break;
-    case ARG_SKIP_TO_FIRST:
+    case PROP_SKIP_TO_FIRST:
       g_value_set_boolean (value, videorate->skip_to_first);
       break;
-    default:
-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    case PROP_DROP_ONLY:
+      g_value_set_boolean (value, videorate->drop_only);
       break;
-  }
-}
-
-static GstStateChangeReturn
-gst_video_rate_change_state (GstElement * element, GstStateChange transition)
-{
-  GstStateChangeReturn ret;
-  GstVideoRate *videorate;
-
-  videorate = GST_VIDEO_RATE (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      videorate->discont = TRUE;
-      videorate->last_ts = -1;
+    case PROP_AVERAGE_PERIOD:
+      g_value_set_uint64 (value, videorate->average_period_set);
       break;
-    default:
+    case PROP_MAX_RATE:
+      g_value_set_int (value, g_atomic_int_get (&videorate->max_rate));
       break;
-  }
-
-  ret = parent_class->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_video_rate_reset (videorate);
+    case PROP_FORCE_FPS:
+      gst_value_set_fraction (value, videorate->force_fps_n,
+          videorate->force_fps_d);
       break;
     default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
-
-  return ret;
+  GST_OBJECT_UNLOCK (videorate);
 }
 
 static gboolean
Index: gst-plugins-base-0.10.32/src/gst/videorate/gstvideorate.h
===================================================================
--- gst-plugins-base-0.10.32.orig/src/gst/videorate/gstvideorate.h	2014-05-28 17:42:20.006256387 -0600
+++ gst-plugins-base-0.10.32/src/gst/videorate/gstvideorate.h	2014-05-28 17:42:21.630256373 -0600
@@ -21,6 +21,7 @@
 #define __GST_VIDEO_RATE_H__
 
 #include <gst/gst.h>
+#include <gst/base/gstbasetransform.h>
 
 G_BEGIN_DECLS
 
@@ -45,9 +46,7 @@
  */
 struct _GstVideoRate
 {
-  GstElement element;
-
-  GstPad *sinkpad, *srcpad;
+  GstBaseTransform parent;
 
   /* video state */
   gint from_rate_numerator, from_rate_denominator;
@@ -63,6 +62,10 @@
   gboolean discont;
   guint64 last_ts;              /* Timestamp of last input buffer */
 
+  guint64 average_period;
+  GstClockTimeDiff wanted_diff; /* target average diff */
+  GstClockTimeDiff average;     /* moving average period */
+
   /* segment handling */
   GstSegment segment;
 
@@ -71,11 +74,16 @@
   gboolean silent;
   gdouble new_pref;
   gboolean skip_to_first;
+  gboolean drop_only;
+  guint64 average_period_set;
+  gint force_fps_n, force_fps_d;
+
+  volatile int max_rate;
 };
 
 struct _GstVideoRateClass
 {
-  GstElementClass parent_class;
+  GstBaseTransformClass parent_class;
 };
 
 GType gst_video_rate_get_type (void);
Index: gst-plugins-base-0.10.32/src/gst/videorate/Makefile.am
===================================================================
--- gst-plugins-base-0.10.32.orig/src/gst/videorate/Makefile.am	2014-05-28 17:42:20.014256387 -0600
+++ gst-plugins-base-0.10.32/src/gst/videorate/Makefile.am	2014-05-28 18:09:02.474242906 -0600
@@ -3,8 +3,8 @@
 plugin_LTLIBRARIES = libgstvideorate.la
 
 libgstvideorate_la_SOURCES = gstvideorate.c
-libgstvideorate_la_CFLAGS = $(GST_CFLAGS)
+libgstvideorate_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS)
 libgstvideorate_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
-libgstvideorate_la_LIBADD = $(GST_LIBS)
+libgstvideorate_la_LIBADD = $(GST_LIBS) $(GST_BASE_LIBS)
 libgstvideorate_la_LIBTOOLFLAGS = --tag=disable-static
 

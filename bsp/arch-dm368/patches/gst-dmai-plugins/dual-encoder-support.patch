Index: gst-dmai-plugins/src/src/gsttidmaibasedualencoder.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaibasedualencoder.c	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,793 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gsttidmaibasevideodualencoder.h"
+#include "gsttidmaibasedualencoder.h"
+#include "gsttidmaibuffertransport.h"
+#include <string.h>
+#include <stdlib.h>
+#include <xdc/std.h>
+#include <ti/sdo/ce/Engine.h>
+#include <ti/sdo/ce/video1/videnc1.h>
+#include <ti/sdo/ce/CERuntime.h>
+
+
+#define GST_CAT_DEFAULT gst_tidmai_base_dualencoder_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+enum
+{
+  PROP_0,
+  PROP_SIZE_OUTPUT_BUF,
+};
+
+static GstElementClass *parent_class = NULL;
+
+static void gst_tidmai_base_dualencoder_buffer_finalize(gpointer data, GstTIDmaiBufferTransport *dmai_buf);
+
+
+/* Free any previus definition of the principal attributes */
+gboolean
+gst_tidmai_base_dualencoder_finalize_attributes (GstTIDmaiBaseDualEncoder * base_dualencoder)
+{
+
+  if (base_dualencoder->submitted_input_buffers != NULL) {
+    gst_buffer_unref (base_dualencoder->submitted_input_buffers);
+    gst_buffer_unref (base_dualencoder->submitted_output_buffers);
+    base_dualencoder->submitted_input_buffers = NULL;
+    base_dualencoder->submitted_output_buffers = NULL;
+  }
+  
+  if(base_dualencoder->freeSlices != NULL) {
+    
+    g_free(base_dualencoder->freeMutex);
+    g_list_free(base_dualencoder->freeSlices);
+    base_dualencoder->freeMutex = NULL;
+    base_dualencoder->freeSlices = NULL;
+    base_dualencoder->outBufSize = 0;
+  }
+  
+  if(base_dualencoder->codec_params != NULL) {
+    g_free(base_dualencoder->codec_params);
+    g_free(base_dualencoder->codec_dynamic_params); 
+    base_dualencoder->codec_params = NULL;
+    base_dualencoder->codec_dynamic_params = NULL;
+  }
+  
+  base_dualencoder->first_buffer = FALSE;
+  
+  return TRUE;
+}
+
+/* Free the codec instance in case of no null */
+static gboolean
+gst_tidmai_base_dualencoder_default_finalize_codec (GstTIDmaiBaseDualEncoder * base_dualencoder)
+{
+
+  if (base_dualencoder->low_resolution_encoder->codec_handle != NULL) {
+    if (!gst_tidmai_base_dualencoder_delete (base_dualencoder, base_dualencoder->low_resolution_encoder))
+      return FALSE;
+  }
+  
+  if (base_dualencoder->high_resolution_encoder->codec_handle != NULL) {
+    if (!gst_tidmai_base_dualencoder_delete (base_dualencoder, base_dualencoder->high_resolution_encoder))
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/* Check for a previews instance of the codec, init the params and create the codec instance */
+static gboolean
+gst_tidmai_base_dualencoder_default_init_codec (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  /* Finalize any previous configuration  */
+  //if (!gst_tidmai_base_dualencoder_finalize_codec (base_dualencoder))
+    //return FALSE;
+
+  /* Set the value of the params */
+  if (!gst_tidmai_base_dualencoder_initialize_params (base_dualencoder, encoder_instance))
+    return FALSE;
+
+  /* Give a chance to downstream caps to modify the params or dynamic
+   * params before we use them
+   */
+  //if (! TIDmai_BASE_VIDEO_DUALENCODER_GET_CLASS(video_dualencoder)->(
+  //  video_dualencoder))
+  //return FALSE;
+
+  /* Create the codec instance */
+  if (!gst_tidmai_base_dualencoder_create (base_dualencoder, encoder_instance))
+    return FALSE;
+
+  return TRUE;
+}
+
+static void
+gst_tidmai_base_dualencoder_base_init (GstTIDmaiBaseDualEncoderClass * klass)
+{
+  /* Initialize dynamic data */
+}
+
+static void
+gst_tidmai_base_dualencoder_base_finalize (GstTIDmaiBaseDualEncoderClass * klass)
+{
+}
+
+static void
+gst_tidmai_base_dualencoder_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstTIDmaiBaseDualEncoder *base_dualencoder = GST_TI_DMAI_BASE_DUALENCODER (object);
+  GST_DEBUG_OBJECT (base_dualencoder, "Entry to set_property base dualencoder");
+  /* Set base params */
+  switch (prop_id) {
+    case PROP_SIZE_OUTPUT_BUF:
+      base_dualencoder->outBufSize = g_value_get_int (value);
+      GST_LOG ("setting \"outBufSize\" to \"%d\"\n", base_dualencoder->outBufSize);
+      break;
+    default:
+      break;
+  }
+
+  GST_DEBUG_OBJECT (base_dualencoder, "Leave set_property base dualencoder");
+}
+
+static void
+gst_tidmai_base_dualencoder_finalize (GObject * object)
+{
+}
+
+static void
+gst_tidmai_base_dualencoder_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  /* Get base params */
+  switch (prop_id) {
+    default:
+      break;
+  }
+}
+
+
+/* Release la unused memory to the correspond slice of free memory */
+void
+gst_tidmai_base_dualencoder_restore_unused_memory (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, GList **actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  gint unused;
+  struct cmemSlice *slice;
+  GstTIDmaiBufferTransport *dmai_buf = (GstTIDmaiBufferTransport *)buffer;
+  
+  /* Change the size of the buffer */
+  Buffer_setNumBytesUsed(dmai_buf->dmaiBuffer, (base_dualencoder->memoryUsed & ~0x1f)
+                                    + 0x20);
+  GST_BUFFER_SIZE(buffer) = base_dualencoder->memoryUsed;
+  
+
+  g_mutex_lock (base_dualencoder->freeMutex);
+  /* Return unused memory */
+  unused =
+      GST_BUFFER_SIZE (encoder_instance->input_buffer) -
+      base_dualencoder->memoryUsed;
+  slice = (struct cmemSlice *) ((*actual_free_slice)->data);
+  slice->start -= unused;
+  slice->size += unused;
+  if (slice->size == 0) {
+    g_free (slice);
+    base_dualencoder->freeSlices =
+        g_list_delete_link (base_dualencoder->freeSlices, *actual_free_slice);
+  }
+  g_mutex_unlock (base_dualencoder->freeMutex);
+
+}
+
+
+/* Default implementation of the post_process method */
+static GstBuffer *
+gst_tidmai_base_dualencoder_default_post_process (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GList * buffers, GList ** actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance)
+{
+	
+  /* For default, first buffer most be have the encode data */
+  GstBuffer *encoder_buffer = buffers->data;
+
+  /* Restore unused memory after encode */
+  gst_tidmai_base_dualencoder_restore_unused_memory (base_dualencoder, encoder_buffer,
+      actual_free_slice, encoder_instance);
+
+  return encoder_buffer;
+}
+
+/* Default implementation to the preprocess method
+ * for transform the buffer before init the encode process */
+static GList *
+gst_tidmai_base_dualencoder_default_pre_process (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, GList ** actual_free_slice, 
+	GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  GstBuffer *output_buffer;
+  GList *inOut_buffers = NULL;
+  GList *input_buffers = NULL;
+  GList *output_buffers = NULL;
+  
+  /*Obtain the slice of the output buffer to use */
+  output_buffer =
+      gst_tidmai_base_dualencoder_get_output_buffer (base_dualencoder, actual_free_slice, encoder_instance);
+
+  input_buffers = g_list_append(input_buffers, buffer);
+  output_buffers = g_list_append(output_buffers, output_buffer);	
+
+  inOut_buffers = g_list_append(inOut_buffers, input_buffers);
+  inOut_buffers = g_list_append(inOut_buffers, output_buffers);
+  
+  return output_buffers;
+}
+
+/* Obtain the free memory slide for being use */
+GList *
+gst_tidmai_base_dualencoder_get_valid_slice (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    gint * size)
+{
+
+  GList *first_fit, *alternative_fit;
+  struct cmemSlice *slice, *maxSliceAvailable;
+  int maxSize = 0;
+
+  /* Find free memory */
+  GST_DEBUG ("Finding free memory");
+  g_mutex_lock (base_dualencoder->freeMutex);
+  first_fit = base_dualencoder->freeSlices;
+  while (first_fit) {
+    slice = (struct cmemSlice *) first_fit->data;
+    GST_DEBUG ("Evaluating free slice from %d to %d", slice->start, slice->end);
+    if (slice->size >= *size) {
+      /* We mark all the memory as buffer at this point
+       * to avoid merges while we are using the area
+       * Once we know how much memory we actually used, we 
+       * update to the real memory size that was used
+       */
+      slice->start += *size;
+      slice->size -= *size;
+      g_mutex_unlock (base_dualencoder->freeMutex);
+      return first_fit;
+    }
+    if (slice->size > maxSize) {
+      maxSliceAvailable = slice;
+      maxSize = slice->size;
+      alternative_fit = first_fit;
+    }
+
+    first_fit = g_list_next (first_fit);
+  }
+  
+  g_print("Free memory not found, using our best available free block of size\n");
+  GST_WARNING
+      ("Free memory not found, using our best available free block of size %d...",
+      *size);
+
+  maxSliceAvailable->start += maxSliceAvailable->size;
+  *size = maxSliceAvailable->size;
+  maxSliceAvailable->size = 0;
+
+  g_mutex_unlock (base_dualencoder->freeMutex);
+  return alternative_fit;
+}
+
+
+/* Function that is call when the buffer is going to be unref */
+static void
+gst_tidmai_base_dualencoder_buffer_finalize (gpointer data, GstTIDmaiBufferTransport *dmai_buf)
+{
+	
+	
+  g_print("Entry gst_tidmai_base_dualencoder_buffer_finalize\n");	
+  
+  GstTIDmaiBaseDualEncoder *base_dualencoder = (GstTIDmaiBaseDualEncoder *)data;
+  g_mutex_lock (base_dualencoder->freeMutex);
+   
+
+  GstBuffer *buffer;
+  guint8 *buffer_data;
+  guint8 *output_buffer_data;
+
+  /* Cast the buffer and obtain the base class */
+  buffer = GST_BUFFER (dmai_buf);
+  
+  /* Access the information of the buffer and the output buffer */
+  buffer_data = GST_BUFFER_DATA(buffer);
+ 
+  
+  output_buffer_data = GST_BUFFER_DATA(base_dualencoder->submitted_output_buffers);
+  
+ 
+
+  if (base_dualencoder->submitted_output_buffers == NULL
+      || base_dualencoder->freeSlices == NULL) {
+    GST_DEBUG ("Releasing memory after memory structures were freed");
+    /* No need for unlock, since it wasn't taked */
+  }
+ 
+  gint spos = buffer_data - output_buffer_data;
+  gint buffer_size = GST_BUFFER_SIZE(buffer);
+  gint epos = spos + buffer_size;
+  struct cmemSlice *slice, *nslice;
+  GList *actual_element;
+ 
+  
+  if (!epos > GST_BUFFER_SIZE(base_dualencoder->submitted_output_buffers)) {
+    GST_ELEMENT_ERROR (base_dualencoder, RESOURCE, NO_SPACE_LEFT, (NULL),
+        ("Releasing buffer how ends outside memory boundaries"));
+  }
+
+  GST_DEBUG ("Releasing memory from %d to %d", spos, epos);
+  actual_element = base_dualencoder->freeSlices;
+  
+  
+  /* Merge free memory */
+  while (actual_element) {
+    slice = (struct cmemSlice *) actual_element->data;
+
+    /* Are we contigous to this block? */
+    if (slice->start == epos) {
+      GST_DEBUG ("Merging free buffer at beggining free block (%d,%d)",
+          slice->start, slice->end);
+      /* Merge with current block */
+      slice->start -= buffer_size;
+      slice->size += buffer_size;
+      /* Merge with previous block? */
+      if (g_list_previous (actual_element)) {
+        nslice = (struct cmemSlice *) g_list_previous (actual_element)->data;
+        if (nslice->end == slice->start) {
+          GST_DEBUG ("Closing gaps...");
+          nslice->end += slice->size;
+          nslice->size += slice->size;
+          g_free (slice);
+          base_dualencoder->freeSlices =
+              g_list_delete_link (base_dualencoder->freeSlices, actual_element);
+        }
+      }
+      g_mutex_unlock (base_dualencoder->freeMutex);
+	  return;
+    }
+    if (slice->end == spos) {
+      GST_DEBUG ("Merging free buffer at end of free block (%d,%d)",
+          slice->start, slice->end);
+      /* Merge with current block */
+      slice->end += buffer_size;
+      slice->size += buffer_size;
+      /* Merge with next block? */
+      if (g_list_next (actual_element)) {
+        nslice = (struct cmemSlice *) g_list_next (actual_element)->data;
+        if (nslice->start == slice->end) {
+          GST_DEBUG ("Closing gaps...");
+          slice->end += nslice->size;
+          slice->size += nslice->size;
+          g_free (nslice);
+          base_dualencoder->freeSlices =
+              g_list_delete_link (base_dualencoder->freeSlices,
+              g_list_next (actual_element));
+        }
+      }
+      g_mutex_unlock (base_dualencoder->freeMutex);
+	  return;
+    }
+    /* Create a new free slice */
+    if (slice->start > epos) {
+      GST_DEBUG ("Creating new free slice %d,%d before %d,%d", spos, epos,
+          slice->start, slice->end);
+      nslice = g_malloc0 (sizeof (struct cmemSlice));
+      nslice->start = spos;
+      nslice->end = epos;
+      nslice->size = buffer_size;
+      base_dualencoder->freeSlices =
+          g_list_insert_before (base_dualencoder->freeSlices, actual_element,
+          nslice);
+      g_mutex_unlock (base_dualencoder->freeMutex);
+	  return;
+    }
+
+    actual_element = g_list_next (actual_element);
+  }
+
+  GST_DEBUG ("Creating new free slice %d,%d at end of list", spos, epos);
+  /* We reach the end of the list, so we append the free slice at the 
+     end
+   */
+  nslice = g_malloc0 (sizeof (struct cmemSlice));
+  nslice->start = spos;
+  nslice->end = epos;
+  nslice->size = buffer_size;
+  base_dualencoder->freeSlices =
+      g_list_insert_before (base_dualencoder->freeSlices, NULL, nslice);
+	   
+	  
+  g_mutex_unlock (base_dualencoder->freeMutex);
+}
+
+
+/* Obtain the out put buffer of the dualencoder */
+GstBuffer *
+gst_tidmai_base_dualencoder_get_output_buffer (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GList ** actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance)
+{
+  
+  Buffer_Attrs  Attrs  = Buffer_Attrs_DEFAULT;
+  Buffer_Handle hBuf;
+  Attrs.reference = TRUE;
+  
+  struct cmemSlice *slice;
+  gint offset;
+  gint size = GST_BUFFER_SIZE(encoder_instance->input_buffer);
+  GstBuffer *output_buffer;
+
+  /* Search for valid free slice of memory */
+  *actual_free_slice =
+      gst_tidmai_base_dualencoder_get_valid_slice (base_dualencoder, &size);
+  if (!*actual_free_slice) {
+    GST_WARNING_OBJECT (base_dualencoder,
+        "Not enough space free on the output buffer");
+    return NULL;
+  }
+  slice = (struct cmemSlice *) ((*actual_free_slice)->data);
+
+
+  /* The offset was already reserved, so we need to correct the start */
+  offset = slice->start - size;
+	
+  /* Set the dmaitransport buffer */
+  hBuf = Buffer_create(size, &Attrs);
+  Buffer_setUserPtr(hBuf, ((Int8 *)GST_BUFFER_DATA(base_dualencoder->submitted_output_buffers)) + offset);
+  Buffer_setNumBytesUsed(hBuf, size);
+  Buffer_setSize(hBuf, size);
+  output_buffer = gst_tidmaibuffertransport_new(hBuf,NULL, NULL);
+  gst_tidmaibuffertransport_set_release_callback(
+        (GstTIDmaiBufferTransport *)output_buffer, gst_tidmai_base_dualencoder_buffer_finalize, base_dualencoder);
+  
+  /*output_buffer = gst_buffer_new();
+  GST_BUFFER_SIZE (output_buffer) = size;
+  GST_BUFFER_MALLOCDATA (output_buffer) = GST_BUFFER_DATA(base_dualencoder->submitted_output_buffers) + offset;
+  GST_BUFFER_DATA (output_buffer) = GST_BUFFER_MALLOCDATA (output_buffer);
+  GST_MINI_OBJECT_GET_CLASS(output_buffer)->finalize = (GstMiniObjectFinalizeFunction) gst_tidmai_base_dualencoder_buffer_finalize;
+  
+  output_buffer_transport =  g_malloc0(sizeof(GstTIDmaiBufferTransport));
+  output_buffer_transport->buffer = *output_buffer;
+  output_buffer_transport->cb_data = base_dualencoder;
+  output_buffer_transport->dmaiBuffer = NULL;*/
+  
+  //gst_buffer_unref(output_buffer);
+  
+  /*GST_BUFFER_SIZE (output_buffer_transport) = size;
+  GST_BUFFER_MALLOCDATA (output_buffer_transport) = GST_BUFFER_DATA(base_dualencoder->submitted_output_buffers) + offset;
+  GST_BUFFER_DATA (output_buffer_transport) = GST_BUFFER_MALLOCDATA (output_buffer_transport);
+  */
+  /* Set the dispose function */
+  /*output_buffer_transport->cb_data = base_dualencoder;
+  output_buffer_transport->dmaiBuffer = NULL;
+  */
+	
+  return (GstBuffer *)output_buffer;
+}
+
+
+/* Process the encode algorithm */
+static GstBuffer *
+gst_tidmai_base_dualencoder_default_encode (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance)
+{
+  GST_DEBUG_OBJECT (base_dualencoder, "Entry");
+
+  GstBuffer *input_buffer;
+  GstBuffer *push_out_buffer;
+  GList *actual_free_slice;
+  GList *input_buffers;
+  GList *output_buffers;
+  GList *result_encoded_buffers;
+
+  /* Reuse the input and output buffers */
+  input_buffer = (GstBuffer *) encoder_instance->input_buffer;
+
+  /* Give the chance of transform the buffer before being encode */
+  input_buffers =
+      gst_tidmai_base_dualencoder_pre_process (base_dualencoder, input_buffer,
+		&actual_free_slice, encoder_instance);
+  
+  output_buffers =  g_list_next(input_buffers);
+  
+  /* Encode the buffer */
+  result_encoded_buffers =
+      gst_tidmai_base_dualencoder_process_sync (base_dualencoder, input_buffers->data,
+		output_buffers->data, encoder_instance);
+    
+  /* Permit to transform encode buffer before push out */
+  push_out_buffer =
+      gst_tidmai_base_dualencoder_post_process (base_dualencoder, result_encoded_buffers,
+		&actual_free_slice, encoder_instance);
+
+  g_list_free(input_buffers->data);
+  g_list_free(output_buffers->data);
+  g_list_free(input_buffers);
+
+  GST_DEBUG_OBJECT (base_dualencoder, "Leave");
+
+  return push_out_buffer;
+
+}
+
+/* Function for Init the Engine for use Codec Engine API */
+gboolean 
+gst_tidmai_base_dualencoder_init_engine(GstTIDmaiBaseDualEncoder *base_dualencoder) {
+  
+  /* Initialize the codec engine run time */
+  CERuntime_init ();
+  
+  /* Init the engine handler */
+  Engine_Error *engine_error = NULL;
+  base_dualencoder->engine_handle =
+      Engine_open ("codecServer", NULL, engine_error);
+
+  if (engine_error != Engine_EOK) {
+    GST_WARNING_OBJECT (base_dualencoder, "Problems in Engine_open with code: %d",
+        (int)engine_error);
+    return FALSE;
+  }
+  
+  return TRUE;
+  
+}
+
+
+/* Function for Init the Engine for use Codec Engine API */
+gboolean 
+gst_tidmai_base_dualencoder_finalize_engine(GstTIDmaiBaseDualEncoder *base_dualencoder) {
+  
+  /* Close the engine handler */
+  Engine_close ((Engine_Handle) base_dualencoder->engine_handle);
+  
+  /* Exit the codec engine run time */
+  CERuntime_exit ();
+  
+  return TRUE;
+  
+}
+
+/* Function for unref the buffers with the metainfo */
+void
+gst_tidmai_base_dualencoder_free_metadata(GstTIDmaiBaseDualEncoder *base_dualencoder){
+	
+  
+  if(NULL != base_dualencoder->motionVector) {
+	 gst_buffer_unref(base_dualencoder->motionVector);
+  }
+  
+  if(NULL != base_dualencoder->MBinfo) {
+	 gst_buffer_unref(base_dualencoder->MBinfo);
+  }
+  
+  if(NULL != base_dualencoder->MBRowInfo) {
+	 gst_buffer_unref(base_dualencoder->MBRowInfo);
+  }
+  
+  if(NULL != base_dualencoder->frameInfo) {
+	 gst_buffer_unref(base_dualencoder->frameInfo);
+  }	
+   	
+}
+
+
+
+/* Function that manage the change state if the base dualencoder */
+static GstStateChangeReturn 
+gst_tidmai_base_dualencoder_change_state(GstElement * element, GstStateChange transition) {
+  
+  GstTIDmaiBaseDualEncoder *base_dualencoder;
+  GstStateChangeReturn result;
+
+  base_dualencoder = GST_TI_DMAI_BASE_DUALENCODER (element);
+  GstTIDmaiDualEncInstance *low_resolution_encoder = 
+	base_dualencoder->low_resolution_encoder;
+  GstTIDmaiDualEncInstance *high_resolution_encoder = 
+	base_dualencoder->high_resolution_encoder;
+  
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if(!gst_tidmai_base_dualencoder_init_engine(base_dualencoder)) {
+        return GST_STATE_CHANGE_FAILURE;
+      }
+	  
+      break;
+	case GST_STATE_CHANGE_READY_TO_PAUSED:
+      
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      GST_DEBUG ("stopping collectpads");
+      gst_collect_pads_stop (base_dualencoder->collect_sink_pads);
+      break; 
+    default:
+      break;
+  }
+
+  result = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+     
+      if (!gst_tidmai_base_dualencoder_finalize_codec (base_dualencoder)) {
+        return GST_STATE_CHANGE_FAILURE;
+      }
+	 
+      gst_tidmai_base_dualencoder_finalize_engine(base_dualencoder);
+      gst_tidmai_base_dualencoder_finalize_attributes (base_dualencoder);
+	  
+	  
+	  /*Free the low and high instance and its fields */
+	  gst_caps_unref(low_resolution_encoder->sink_caps);
+	  g_free(low_resolution_encoder->media_info);
+	  gst_collect_pads_remove_pad (base_dualencoder->collect_sink_pads, 
+		low_resolution_encoder->collect->pad);
+	  g_free(low_resolution_encoder);
+	  
+	  //gst_caps_unref(high_resolution_encoder->sink_caps);
+	  g_free(high_resolution_encoder->media_info);
+	  gst_collect_pads_remove_pad (base_dualencoder->collect_sink_pads, 
+		high_resolution_encoder->collect->pad);
+	  g_free(high_resolution_encoder);
+	  
+	  gst_object_unref (base_dualencoder->collect_sink_pads);
+	  
+	  /* Free the buffers for save the metadata */
+      gst_tidmai_base_dualencoder_free_metadata(base_dualencoder);  
+	  
+      break;
+    default:
+      break;
+  }
+
+  return result;
+}
+
+static void
+gst_tidmai_base_dualencoder_class_init (GstTIDmaiBaseDualEncoderClass * klass)
+{
+  
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  parent_class = g_type_class_peek_parent (klass);
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  /* Init debug instancbase_dualencoder_finalize_codece */
+  GST_DEBUG_CATEGORY_INIT (gst_tidmai_base_dualencoder_debug, "cebasedualencoder", 0,
+      "CodecEngine base dualencoder class");
+
+  GST_DEBUG ("ENTER");
+
+  /* Instance the class methods */
+  klass->base_dualencoder_encode = gst_tidmai_base_dualencoder_default_encode;
+  klass->base_dualencoder_finalize_codec =
+      gst_tidmai_base_dualencoder_default_finalize_codec;
+  klass->base_dualencoder_init_codec = gst_tidmai_base_dualencoder_default_init_codec;
+  klass->base_dualencoder_post_process = gst_tidmai_base_dualencoder_default_post_process;
+  klass->base_dualencoder_pre_process = gst_tidmai_base_dualencoder_default_pre_process;
+
+  /* Override inheritance methods */
+  gobject_class->set_property = gst_tidmai_base_dualencoder_set_property;
+  gobject_class->get_property = gst_tidmai_base_dualencoder_get_property;
+  gobject_class->finalize = gst_tidmai_base_dualencoder_finalize;
+  //gstelement_class->request_new_pad /* queda pendiente */
+  gstelement_class->change_state = 
+      GST_DEBUG_FUNCPTR (gst_tidmai_base_dualencoder_change_state);
+
+  /* Instal class properties */
+  g_object_class_install_property (gobject_class, PROP_SIZE_OUTPUT_BUF,
+      g_param_spec_int ("outputBufferSize",
+          "Size of the output buffer",
+          "Size of the output buffer", 0, G_MAXINT32, 0, G_PARAM_READWRITE));
+
+  GST_DEBUG ("LEAVING");
+
+}
+
+void
+gst_tidmai_base_dualencoder_class_finalize (GstTIDmaiBaseDualEncoderClass * klass,
+    gpointer * class_data)
+{
+}
+
+static void
+gst_tidmai_base_dualencoder_init (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstTIDmaiBaseDualEncoderClass * base_encode_class)
+{ 
+  
+  GST_DEBUG_OBJECT (base_dualencoder, "Entry _init base dualencoder");
+
+  /* Init the attributes */
+  base_dualencoder->codec_params = NULL;
+  base_dualencoder->codec_dynamic_params = NULL;
+  base_dualencoder->submitted_input_buffers = NULL;
+  base_dualencoder->submitted_output_buffers = NULL;
+  base_dualencoder->first_buffer = FALSE;
+  base_dualencoder->outBufSize = 0;
+  base_dualencoder->freeMutex = NULL;
+  base_dualencoder->freeSlices = NULL;
+  base_dualencoder->low_resolution_encoder = NULL;
+  base_dualencoder->high_resolution_encoder = NULL;
+  base_dualencoder->motionVector = NULL;
+  base_dualencoder->MBinfo = NULL;
+  base_dualencoder->MBRowInfo = NULL;
+  base_dualencoder->frameInfo = NULL;
+ 
+  
+  /* Init the GstCollectPads */
+  base_dualencoder->collect_sink_pads = gst_collect_pads_new ();	
+  
+  GST_DEBUG ("starting collectpads");
+  gst_collect_pads_start (base_dualencoder->collect_sink_pads);
+  
+  /* Init the low and high resolution encoder */
+  base_dualencoder->low_resolution_encoder = g_malloc0(sizeof(GstTIDmaiDualEncInstance));
+   base_dualencoder->low_resolution_encoder->codec_handle = NULL;
+    base_dualencoder->low_resolution_encoder->input_buffer = NULL;
+  base_dualencoder->low_resolution_encoder->collect = NULL; 
+  base_dualencoder->high_resolution_encoder = g_malloc0(sizeof(GstTIDmaiDualEncInstance));
+   base_dualencoder->high_resolution_encoder->codec_handle = NULL;
+   base_dualencoder->high_resolution_encoder->input_buffer = NULL;
+  base_dualencoder->high_resolution_encoder->collect = NULL;
+  
+  
+  GST_DEBUG_OBJECT (base_dualencoder, "Leave _init base dualencoder");
+
+}
+
+/* Obtain and register the type of the class */
+GType
+gst_tidmai_base_dualencoder_get_type (void)
+{
+
+  static GType object_type = 0;
+
+  if (object_type == 0) {
+
+    static const GTypeInfo object_info = {
+      sizeof (GstTIDmaiBaseDualEncoderClass),
+      (GBaseInitFunc) gst_tidmai_base_dualencoder_base_init,
+      (GBaseFinalizeFunc) gst_tidmai_base_dualencoder_base_finalize,
+      (GClassInitFunc) gst_tidmai_base_dualencoder_class_init,
+      NULL,
+      NULL,
+      sizeof (GstTIDmaiBaseDualEncoder),
+      0,
+      (GInstanceInitFunc) gst_tidmai_base_dualencoder_init,
+    };
+
+    object_type = g_type_register_static (GST_TYPE_ELEMENT,
+        "GstTIDmaiBaseDualEncoder", &object_info, 0);
+  }
+
+  return object_type;
+};
+
+/* Reconfig the output buffer size of the dualencoder */
+void
+gst_tidmai_base_dualencoder_shrink_output_buffer (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, gsize new_size)
+{
+}
Index: gst-dmai-plugins/src/src/gsttidmaibasedualencoder.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaibasedualencoder.h	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,282 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifndef _GST_TI_DMAI_BASE_DUALENCODER_H_
+#define _GST_TI_DMAI_BASE_DUALENCODER_H_
+
+#include <gst/gst.h>
+#include <pthread.h>
+#include <ti/sdo/ce/video1/videnc1.h>
+#include <ti/sdo/dmai/Dmai.h>
+#include <ti/sdo/dmai/Buffer.h>
+#include <ti/sdo/dmai/BufferGfx.h>
+#include <ti/sdo/dmai/BufTab.h>
+#include <gst/base/gstcollectpads.h>
+#include "gsttidmaienc.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_TI_DMAI_BASE_DUALENCODER \
+  (gst_tidmai_base_dualencoder_get_type())
+#define GST_TI_DMAI_BASE_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TI_DMAI_BASE_DUALENCODER,GstTIDmaiBaseDualEncoder))
+#define GST_TI_DMAI_BASE_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TI_DMAI_BASE_DUALENCODER,GstTIDmaiBaseDualEncoderClass))
+#define GST_IS_TI_DMAI_BASE_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TI_DMAI_BASE_DUALENCODER))
+#define GST_IS_TI_DMAI_BASE_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TI_DMAI_BASE_DUALENCODER))
+#define GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TI_DMAI_BASE_DUALENCODER, GstTIDmaiBaseDualEncoderClass  ))
+typedef struct _GstTIDmaiBaseDualEncoder GstTIDmaiBaseDualEncoder;
+typedef struct _GstTIDmaiBaseDualEncoderClass GstTIDmaiBaseDualEncoderClass;
+typedef struct _GstTIDmaiDualEncInstance GstTIDmaiDualEncInstance;
+
+
+/* Struct for save especific configs for the two encoders instances */
+struct _GstTIDmaiDualEncInstance
+{
+  GstPad *src_pad;
+  GstCaps *sink_caps;
+  gpointer codec_handle;
+  gpointer media_info;
+  GstCollectData *collect;
+  GstBuffer *input_buffer;
+  
+};
+
+
+/**
+ * This is the base class for the CodecEngine based dualencoders
+ * @extends GstElement
+ */
+struct _GstTIDmaiBaseDualEncoder
+{
+  GstElement element;
+
+  /********************/
+  /**Sink pads manage**/
+  /********************/
+  GstCollectPads *collect_sink_pads; /* src pads are manage in the specific instances(low and high resolution) */
+
+  /* Members for encode process */
+  gchar *codec_name;
+
+  /* Handler for the dualencoder instance */
+  gpointer engine_handle;
+
+  /* Static params for indicate the behavior of the dualencoder */
+  gpointer codec_params;
+  
+  /* Static params for indicate the behavior of the dualencoder in run time */
+  gpointer codec_dynamic_params;
+
+  /* Pointers to hold data submitted into CodecEngine */
+  /* Input buffer for the dualencoder instance */
+  GstBuffer *submitted_input_buffers;
+
+  /* Output arguments of the dualencoder instance */
+  GstBuffer *submitted_output_buffers;
+
+  /* Mark that if the first buffer was encode */
+  gboolean first_buffer;
+
+  /*********************/
+  /** Buffer managent **/
+  /*********************/
+  /* Memory uses in last encode process */
+  gint memoryUsed;
+
+  /* Size of the complete ouput buffer */
+  gint outBufSize;
+
+   /* Size of the complete input buffer */
+  gint inBufSize;
+
+  /* First element of the list that control the free memory in out_buffers */
+  GList *freeSlices;
+
+  /* Mutex for control the manipulation to out_buffers */
+  GMutex *freeMutex;
+  
+  /*******************************/
+  /** Encoders instances manage **/
+  /*******************************/
+  GstTIDmaiDualEncInstance *low_resolution_encoder;
+  GstTIDmaiDualEncInstance *high_resolution_encoder;
+  GstBuffer *motionVector;
+  GstBuffer *MBinfo;
+  GstBuffer *MBRowInfo;
+  GstBuffer *frameInfo;
+ 
+};
+
+struct _GstTIDmaiBaseDualEncoderClass
+{
+  GstElementClass parent_class;
+
+    gboolean (*base_dualencoder_initialize_params) (GstTIDmaiBaseDualEncoder *
+      base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance);
+    gboolean (*base_dualencoder_control) (GstTIDmaiBaseDualEncoder * base_dualencoder,
+        GstTIDmaiDualEncInstance *encoder_instance, gint cmd_id, VIDENC1_Status *encStatus);
+    gboolean (*base_dualencoder_delete) (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+		GstTIDmaiDualEncInstance *encoder_instance);
+    gboolean (*base_dualencoder_create) (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+		GstTIDmaiDualEncInstance *encoder_instance);
+    GList* (*base_dualencoder_process_sync) (GstTIDmaiBaseDualEncoder * base_dualencoder,
+      GList *input_buffers, GList *output_buffers, GstTIDmaiDualEncInstance *encoder_instance);
+    GstBuffer* (*base_dualencoder_encode) (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+		GstTIDmaiDualEncInstance *encoder_instance);
+    gboolean (*base_dualencoder_init_codec) (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+		GstTIDmaiDualEncInstance *encoder_instance);
+    gboolean (*base_dualencoder_finalize_codec) (GstTIDmaiBaseDualEncoder * base_dualencoder);
+    //void (*base_dualencoder_buffer_add_cmem_meta) (GstBuffer * buffer);
+  GstBuffer *(*base_dualencoder_post_process) (GstTIDmaiBaseDualEncoder * base_dualencoder,
+      GList * buffers, GList ** actual_free_slice, 
+	  GstTIDmaiDualEncInstance *encoder_instance);
+  GList *(*base_dualencoder_pre_process) (GstTIDmaiBaseDualEncoder * base_dualencoder,
+      GstBuffer * buffer, GList ** actual_free_slice, 
+	  GstTIDmaiDualEncInstance *encoder_instance);
+  void (*base_dualencoder_alloc_params) (GstTIDmaiBaseDualEncoder * base_dualencoder);   
+      
+};
+
+
+GType gst_tidmai_base_dualencoder_get_type (void);
+
+/* Macros that allow access to the methods of the class */
+
+/*------------------*/
+/* Public functions */
+/*------------------*/
+
+#define gst_tidmai_base_dualencoder_encode(obj, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_encode(obj, enc_instance)
+
+#define gst_tidmai_base_dualencoder_alloc_params(obj) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_alloc_params(obj)
+
+#define gst_tidmai_base_dualencoder_pre_process(obj, buf, actual_slice, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_pre_process(obj, buf, actual_slice ,enc_instance)
+
+#define gst_tidmai_base_dualencoder_post_process(obj, buf, actual_slice, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_post_process(obj, buf, actual_slice, enc_instance)
+
+#define gst_tidmai_base_dualencoder_finalize_codec(obj) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_finalize_codec(obj)
+
+#define gst_tidmai_base_dualencoder_init_codec(obj, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_init_codec(obj, enc_instance)
+
+#define gst_tidmai_base_dualencoder_process_sync(obj, input_buf, output_buf, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_process_sync(obj, input_buf, output_buf, enc_instance)
+
+
+
+
+
+/*--------------------*/
+/* Abstract functions */
+/*--------------------*/
+
+/** 
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @fn void gst_tidmai_base_dualencoder_initialize_params(_GstTIDmaiBaseDualEncoder *base_dualencoder)
+ * @brief Abstract function that implements the initialization of static
+ *  and dynamic parameters for the codec.
+ * @details This function is implemented by a sub-class that handles the right CodecEngine API (live VIDENC1, or IMGENC)
+ * @param base_dualencoder a pointer to a _GstTIDmaiBaseDualEncoder object
+ * @protected
+ */
+#define gst_tidmai_base_dualencoder_initialize_params(obj, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_initialize_params(GST_TI_DMAI_BASE_DUALENCODER(obj), enc_instance)
+
+
+/** 
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @fn gint32 gst_tidmai_base_dualencoder_control(_GstTIDmaiBaseDualEncoder *base_dualencoder)
+ * @brief Abstract function that implements controlling behavior of the codec.
+ * @details This function is implemented by a sub-class that handles the right CodecEngine API (live VIDENC1, or IMGENC)
+ * @param base_dualencoder a pointer to a _GstCEBaseDualEncoder object
+ * @protected
+ */
+#define gst_tidmai_base_dualencoder_control(obj, enc_instance, cmd, status) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_control(GST_TI_DMAI_BASE_DUALENCODER(obj), enc_instance, cmd, status)
+
+/** 
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @fn void gst_tidmai_base_dualencoder_delete(_GstTIDmaiBaseDualEncoder *base_dualencoder)
+ * @brief Abstract function that implements deleting the instance of the codec.
+ * @details This function is implemented by a sub-class that handles the right CodecEngine API (live VIDENC1, or IMGENC)
+ * @param base_dualencoder a pointer to a _GstTIDmaiBaseDualEncoder object
+ * @protected
+ */
+#define gst_tidmai_base_dualencoder_delete(obj, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_delete(GST_TI_DMAI_BASE_DUALENCODER(obj), enc_instance)
+
+/** 
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @fn gpointer gst_tidmai_base_dualencoder_create(_GstTIDmaiBaseDualEncoder *base_dualencoder)
+ * @brief Abstract function that implements creating an instance of the codec
+ * @details This function is implemented by a sub-class that handles the right CodecEngine API (live VIDENC1, or IMGENC)
+ * @param base_dualencoder a pointer to a _GstTIDmaiBaseDualEncoder object
+ * @protected
+ */
+#define gst_tidmai_base_dualencoder_create(obj, enc_instance) \
+  GST_TI_DMAI_BASE_DUALENCODER_GET_CLASS(obj)->base_dualencoder_create(GST_TI_DMAI_BASE_DUALENCODER(obj), enc_instance)
+
+
+
+/* Auxiliar functions for the class
+ * Work similar to public methods  */
+
+void
+gst_tidmai_base_dualencoder_restore_unused_memory (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, GList ** actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance);
+
+GstBuffer *gst_tidmai_base_dualencoder_get_output_buffer (GstTIDmaiBaseDualEncoder *
+    base_dualencoder, GList ** actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance);
+
+/**
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @brief Allocates buffers for share efficiently with co-processors
+ * @details This function allocates GstBuffers that are contiguous on memory
+ *  (have #_GstCMEMMeta). This buffers can be shrinked efficiently to re-use the
+ *  limited-available contiguous memory.
+ * @param base_dualencoder a pointer to a _GstTIDmaiBaseDualEncoder object
+ * @param size the size of the buffer
+ */
+GstBuffer *gst_tidmai_base_dualencoder_get_cmem_buffer (GstTIDmaiBaseDualEncoder *
+    base_dualencoder, gsize size);
+
+/**
+ * @memberof _GstTIDmaiBaseDualEncoder
+ * @brief Shrink output buffers for re-use memory
+ * @details This function shrinked efficiently (using CMEN) to re-use the
+ *  limited-available contiguous memory.
+ * @param base_dualencoder a pointer to a _GstTIDmaiBaseDualEncoder object
+ * @param buffer buffer to be re-size
+ * @param new_size new size for the buffer
+ */
+void gst_tidmai_base_dualencoder_shrink_output_buffer (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, gsize new_size);
+
+
+gboolean
+gst_tidmai_base_dualencoder_finalize_attributes (GstTIDmaiBaseDualEncoder * base_dualencoder);
+
+G_END_DECLS
+#endif
Index: gst-dmai-plugins/src/src/gsttidmaibasevideodualencoder.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaibasevideodualencoder.c	2012-09-03 17:40:00.057165282 -0600
@@ -0,0 +1,621 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+       */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gsttidmaibasevideodualencoder.h"
+#include "gsttidmaibuffertransport.h"
+#include <xdc/std.h>
+#include <ti/sdo/ce/Engine.h>
+#include <ti/sdo/ce/video1/videnc1.h>
+#include <string.h>
+#include <pthread.h>
+#include <ti/sdo/dmai/Dmai.h>
+#include <ti/sdo/dmai/Buffer.h>
+#include <ti/sdo/dmai/BufferGfx.h>
+#include <ti/sdo/dmai/BufTab.h>
+#include <ti/sdo/codecs/h264enc/ih264venc.h>
+#include <ti/sdo/ce/osal/Memory.h>
+
+
+
+#define GST_CAT_DEFAULT gst_tidmai_base_video_dualencoder_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+
+enum
+{
+  PROP_25=25,
+};
+
+
+/* Struct for save the motion vector data */
+typedef struct MVSAD_Interface
+{
+	XDAS_UInt32 sad;
+	XDAS_UInt16 mvX;
+	XDAS_UInt16 mvY;
+} MVSAD_Interface ;
+
+
+static 
+void gst_tidmai_base_video_dualencoder_finalize (GObject * object);
+
+/******************************************************************************
+ * gst_tidmai_h264_dualencoder_finalize
+ *****************************************************************************/
+static 
+void gst_tidmai_base_video_dualencoder_finalize (GObject * object)
+{
+    GstTIDmaiBaseVideoDualEncoder *base_video_dualencoder = (GstTIDmaiBaseVideoDualEncoder *)object;
+    
+	g_free(base_video_dualencoder->set_caps_mutex);
+
+    G_OBJECT_CLASS(g_type_class_peek_parent(G_OBJECT_GET_CLASS (object)))
+        ->finalize (object);
+}
+
+
+
+/******************************************************************************
+ * gst_tidmaienc_sink_event
+ *     Perform event processing.
+ ******************************************************************************/
+gboolean 
+gst_tidmai_base_video_dualencoder_sink_event(GstPad *pad, GstEvent *event)
+{	
+	
+	GST_DEBUG("Entry");
+    gboolean      ret = FALSE;
+	GstPad *src_pad;
+	GstTIDmaiBaseDualEncoder *base_dualencoder = 
+		(GstTIDmaiBaseDualEncoder *) gst_pad_get_parent(pad);
+	
+   /* Determinate the encoder instance */
+    if(base_dualencoder->low_resolution_encoder->collect->pad ==
+		pad) {
+		 src_pad = base_dualencoder->low_resolution_encoder->src_pad;
+		 GST_DEBUG("Actual instance: low resolution");
+	  }
+	 else if(base_dualencoder->high_resolution_encoder->collect->pad ==
+			pad) {
+		 src_pad = base_dualencoder->high_resolution_encoder->src_pad;
+		 GST_DEBUG("Actual instance: high resolution");
+	  }
+	 else {
+		 GST_WARNING("Fail in determina the actual encoder instance!");
+		 return ret;
+	  }
+
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_EOS:
+        ret = gst_pad_push_event(src_pad, event);
+        break;
+    default:
+        ret = gst_pad_push_event(src_pad, event);
+		break;
+    }
+	
+	GST_DEBUG("Leave");
+	
+    return ret;
+}
+
+
+
+static void
+gst_tidmai_base_video_dualencoder_base_init (GstTIDmaiBaseVideoDualEncoderClass * klass)
+{
+  /* Initialize dynamic data */
+}
+
+static void
+gst_tidmai_base_video_dualencoder_base_finalize (GstTIDmaiBaseVideoDualEncoderClass * klass)
+{
+}
+
+static void
+gst_tidmai_base_video_dualencoder_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  switch (prop_id) {
+    default:
+      break;
+  }
+
+}
+
+static void
+gst_tidmai_base_video_dualencoder_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  switch (prop_id) {
+    default:
+      break;
+  }
+}
+
+/* Default implementation of the method  video_dualencoder_sink_set_caps */
+gboolean
+gst_tidmai_base_video_dualencoder_sink_set_caps (GstPad * pad, GstCaps * caps)
+{
+
+  GST_DEBUG("Entry default_sink_set_caps base video dualencoder");
+  
+  GstStructure *capStruct;
+  gint framerateNum;
+  gint framerateDen;
+  guint32 fourcc;
+  GstTIDmaiVideoInfo *video_info;
+  GstTIDmaiDualEncInstance *actual_encoder_instance;
+  GstTIDmaiBaseDualEncoder *base_dualencoder = (GstTIDmaiBaseDualEncoder *)gst_pad_get_parent(pad);
+  GstTIDmaiBaseVideoDualEncoder *video_dualencoder = GST_TI_DMAI_BASE_VIDEO_DUALENCODER(base_dualencoder);
+  
+  /* Lock the entry */
+  g_mutex_lock(video_dualencoder->set_caps_mutex);
+  
+  /* Check the current encoder instance */
+  if(base_dualencoder->low_resolution_encoder->collect->pad ==
+	 pad) {
+	 actual_encoder_instance = base_dualencoder->low_resolution_encoder;
+	 GST_DEBUG("Actual instance: low resolution");
+  }
+  else if(base_dualencoder->high_resolution_encoder->collect->pad ==
+	 pad) {
+	 actual_encoder_instance = base_dualencoder->high_resolution_encoder;
+	 GST_DEBUG("Actual instance: high resolution");
+  }
+  else {
+	 GST_WARNING("Fail in determinate the actual encoder instance!");
+	 goto refuse_caps;
+  }
+  
+  /* Init the video info */
+  video_info = g_malloc0(sizeof(GstTIDmaiVideoInfo));
+  
+  capStruct = gst_caps_get_structure(caps, 0);
+  /* get info from caps */
+  
+
+  if (gst_structure_get_fraction(capStruct, "framerate", &framerateNum,
+      &framerateDen)) {
+	video_info->framerateN = framerateNum;
+    video_info->framerateD = framerateDen;
+  
+  } else {
+    GST_WARNING("Problems for obtain framerate!");
+	goto refuse_caps;
+  }
+
+  if (!gst_structure_get_int(capStruct, "height", &video_info->height)) {
+	video_info->height = 0;
+  }
+
+  if (!gst_structure_get_int(capStruct, "width", &video_info->width)) {
+	video_info->width = 0;
+  }
+
+  if (!gst_structure_get_int(capStruct, "pitch", &video_info->pitch)) {
+	video_info->pitch = 0;
+  }
+
+  if (gst_structure_get_fourcc(capStruct, "format", &fourcc)) {
+
+	switch (fourcc) {
+       case GST_MAKE_FOURCC('N', 'V', '1', '2'):
+            video_info->colorSpace = ColorSpace_YUV420PSEMI;
+			/*base_dualencoder->inBufSize = (video_info->height * video_info->width) * (3 / 2);*/ /* The encoder instance B (high resolution), set this field adequately */
+            break;
+       default:
+            GST_WARNING("Unsupported fourcc in video stream!");
+                goto refuse_caps;
+            }
+   }
+
+  actual_encoder_instance->media_info = video_info;
+  
+  /* We are ready to init the codec */
+  if (!gst_tidmai_base_dualencoder_init_codec (base_dualencoder, actual_encoder_instance))
+    goto refuse_caps;
+
+  /* save the caps for then update the caps */
+  actual_encoder_instance->sink_caps = caps;
+   
+  gst_object_unref(base_dualencoder);
+
+  GST_DEBUG("Leave default_sink_set_caps base video dualencoder");
+  
+  /* Un-lock the entry */
+  g_mutex_unlock(video_dualencoder->set_caps_mutex);
+   	
+  return TRUE;
+	
+  /* ERRORS */
+refuse_caps:
+  {
+	  
+    GST_ERROR ("refused caps %" GST_PTR_FORMAT, caps);
+	
+	/* Un-lock the entry */ 
+	g_mutex_unlock(video_dualencoder->set_caps_mutex);
+	
+    return FALSE;
+  }
+}
+
+
+/* Default implementation for sink_get_caps */
+static GstCaps *
+gst_tidmai_base_video_dualencoder_default_sink_get_caps (GstPad * pad, GstCaps * filter)
+{
+  /*GstTIDmaiBaseVideoDualEncoder *video_dualencoder =
+      GST_TI_DMAI_BASE_VIDEO_DUALENCODER (gst_pad_get_parent (pad));*/
+  GstCaps *caps_result = NULL;
+  //const GstCaps *sink_caps;
+
+  /*sink_caps = gst_pad_get_pad_template_caps (pad);
+  
+  if(filter) {
+    caps_result = gst_caps_intersect (filter, sink_caps);
+  }
+  else {
+    caps_result = sink_caps;
+  }
+  */
+  return caps_result;
+  
+  /* Intersect the caps */
+  
+  /* If we already have caps return them */
+  //if ((caps = gst_pad_get_current_caps (pad)) != NULL) {
+    //goto done;
+ // }
+
+  /* we want to proxy properties like width, height and framerate from the 
+     other end of the element */
+  /*othercaps = gst_pad_peer_query_caps (base_dualencoder->src_pad, filter);
+  if (othercaps == NULL ||
+      gst_caps_is_empty (othercaps) || gst_caps_is_any (othercaps)) {
+    caps = gst_caps_copy (gst_pad_get_pad_template_caps (pad));
+    goto done;
+  }
+
+  caps = gst_caps_new_empty ();
+  templ = gst_pad_get_pad_template_caps (pad);
+*/
+  /* Set caps with peer caps values */
+  //for (i = 0; i < gst_caps_get_size (templ); i++) {
+    /* pick fields from peer caps */
+    /*for (j = 0; j < gst_caps_get_size (othercaps); j++) {
+      GstStructure *s = gst_caps_get_structure (othercaps, j);
+      const GValue *val;
+      
+      structure = gst_structure_copy (gst_caps_get_structure (templ, i));
+      if ((val = gst_structure_get_value (s, "width")))
+        gst_structure_set_value (structure, "width", val);
+      if ((val = gst_structure_get_value (s, "height")))
+        gst_structure_set_value (structure, "height", val);
+      if ((val = gst_structure_get_value (s, "framerate")))
+        gst_structure_set_value (structure, "framerate", val);
+
+      gst_caps_merge_structure (caps, structure);
+    }
+  }
+
+done:
+  gst_caps_replace (&othercaps, NULL);
+  gst_object_unref (video_dualencoder);
+
+  return caps;*/
+}
+
+
+/* Default implementation for _chain */
+static GstFlowReturn
+gst_tidmai_base_video_dualencoder_default_realize_instance (GstTIDmaiBaseVideoDualEncoder *video_dualencoder,
+	GstTIDmaiDualEncInstance *encoder_instance, GstBuffer *entry_buffer)
+{
+
+  GST_DEBUG_OBJECT (video_dualencoder, "Entry gst_tidmai_base_video_dualencoder_default_realize_instance");
+  
+  /* Only for test */
+  //GstClockTime time_start, time_start2, time_end, time_end2;
+  //GstClockTimeDiff time_diff;
+  Buffer_Attrs	Attrs; 
+  Buffer_Handle outBufHandle;
+  //Buffer_Attrs	inAttrs; 
+  //Buffer_Handle inBufHandle;
+  GstTIDmaiVideoInfo *video_info;
+  UInt32 phys = 10;
+  Bool isContiguous = FALSE;
+  
+  //time_start = gst_util_get_timestamp ();
+  
+  int ret;
+  GstBuffer *buffer_push_out;
+  
+  /* Tests if the buffer  */
+  phys = Memory_getBufferPhysicalAddress(
+                    GST_BUFFER_DATA(entry_buffer),
+                    GST_BUFFER_SIZE(entry_buffer),
+							&isContiguous);
+	
+  if(phys == 0) {
+	GST_ERROR_OBJECT (video_dualencoder, "Entry buffer isn't CMEM");
+	return GST_FLOW_NOT_SUPPORTED;
+  }
+  else {
+	GST_DEBUG_OBJECT (video_dualencoder, "Using buffers with contiguos memory");
+	encoder_instance->input_buffer = entry_buffer;
+  }
+	
+  /* Check for the output_buffer */
+  if (GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->submitted_output_buffers == NULL) {
+    
+	video_info = (GstTIDmaiVideoInfo *) GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->high_resolution_encoder->media_info;
+	GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->inBufSize = (video_info->width * video_info->height) * 1.8;
+	
+	
+    if (GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->outBufSize == 0) {
+      /* Default value for the out buffer size */
+      GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->outBufSize =
+          GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->inBufSize * 5;
+    }
+
+    /* Add the free memory slice to the list */
+    struct cmemSlice *slice = g_malloc0 (sizeof (struct cmemSlice));
+    slice->start = 0;
+    slice->end = GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->outBufSize;
+    slice->size = GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->outBufSize;
+    GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->freeMutex = g_malloc0(sizeof(GMutex));
+    g_mutex_init(GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->freeMutex);
+    GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->freeSlices =
+        g_list_append (GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->freeSlices, slice);
+
+    /* Allocate the circular buffer */
+	
+	Attrs = Buffer_Attrs_DEFAULT;
+	Attrs.useMask = gst_tidmaibuffertransport_GST_FREE;
+	
+	outBufHandle = Buffer_create(GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->outBufSize, &Attrs);
+	
+	GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder)->submitted_output_buffers = 
+		gst_tidmaibuffertransport_new(outBufHandle, NULL, NULL);
+	
+  }
+  /* Encode the actual buffer */
+  buffer_push_out =  gst_tidmai_base_dualencoder_encode (GST_TI_DMAI_BASE_DUALENCODER (video_dualencoder), 
+						encoder_instance);
+
+  
+   	  
+  gst_buffer_copy_metadata(buffer_push_out, entry_buffer, 
+    GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS); 
+  
+  
+  //time_end = gst_util_get_timestamp ();
+   
+    
+  //time_diff = GST_CLOCK_DIFF (time_start, time_end);
+  //g_print ("DualEncoder time: %" G_GUINT64_FORMAT " ns.\n", time_diff);
+    
+    
+  /* push the buffer and check for any error */
+  //time_start2 = gst_util_get_timestamp ();
+	
+  GST_BUFFER_CAPS (buffer_push_out) = gst_caps_ref(GST_PAD_CAPS(encoder_instance->src_pad)); 
+  
+  ret =
+      gst_pad_push (encoder_instance->src_pad,
+			buffer_push_out);
+  
+			
+    //time_end2 = gst_util_get_timestamp ();
+    
+    
+    //time_diff = GST_CLOCK_DIFF (time_start2, time_end2);
+    
+  //g_print ("\nPush time: %" G_GUINT64_FORMAT " ns.\n\n", time_diff);
+    
+    
+  if (GST_FLOW_OK != ret) {
+    GST_ERROR_OBJECT (video_dualencoder, "Push buffer return with error: %d",
+        ret);
+  }
+ 
+  GST_DEBUG_OBJECT (video_dualencoder, "Leave gst_tidmai_base_video_dualencoder_default_realize_instance");
+  
+  return ret;
+}
+
+/* Function for sent each encoder instance to be process after collect the buffers in the sink pads */
+GstFlowReturn
+gst_tidmai_base_video_dualencoder_entry_buffers_collected (GstCollectPads * pads, GstTIDmaiBaseVideoDualEncoder * video_dualencoder) {
+	
+	
+	
+	GST_DEBUG_OBJECT (video_dualencoder, "Entry gst_tidmai_base_video_dualencoder_entry_buffers_collected");
+	
+	GstTIDmaiBaseDualEncoder *base_dualencoder = GST_TI_DMAI_BASE_DUALENCODER(video_dualencoder);
+	GstFlowReturn ret;
+	GstBuffer *low_res_buffer;
+	GstBuffer *high_res_buffer;
+	
+	/* Obtain the buffers */
+	low_res_buffer = gst_collect_pads_pop (base_dualencoder->collect_sink_pads, 
+									base_dualencoder->low_resolution_encoder->collect);
+	high_res_buffer = gst_collect_pads_pop (base_dualencoder->collect_sink_pads, 
+									base_dualencoder->high_resolution_encoder->collect);
+	
+	/* Process for the low resolution instance */
+	GST_DEBUG_OBJECT (video_dualencoder, "Process low resolution instance");
+	ret = gst_tidmai_base_video_dualencoder_realize_instance(video_dualencoder, 
+			base_dualencoder->low_resolution_encoder, low_res_buffer);
+	
+	/* Process for the high resolution instance */
+	GST_DEBUG_OBJECT (video_dualencoder, "Process high resolution instance");
+	ret = gst_tidmai_base_video_dualencoder_realize_instance(video_dualencoder, 
+			base_dualencoder->high_resolution_encoder, high_res_buffer);
+			
+	/* unref the buffer with the high-resolution for being reuse for the driver */
+	gst_buffer_unref(high_res_buffer);
+	if(1 == GST_MINI_OBJECT_REFCOUNT(high_res_buffer)) {
+		gst_buffer_unref(high_res_buffer);
+	}
+      	
+	GST_DEBUG_OBJECT (video_dualencoder, "Leave gst_tidmai_base_video_dualencoder_entry_buffers_collected");
+	
+	return ret;
+	
+}
+
+/* Function for process the request pads */
+GstPad *
+gst_tidmai_base_video_dualencoder_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * req_name) {
+  
+  GstPad *new_sink_pad = NULL;
+  GstTIDmaiBaseVideoDualEncoder *video_dualencoder = 
+	GST_TI_DMAI_BASE_VIDEO_DUALENCODER(element);
+  gchar *pad_name = NULL; 
+  GstTIDmaiBaseDualEncoder *base_dualencoder = 
+	GST_TI_DMAI_BASE_DUALENCODER(video_dualencoder);
+  GstTIDmaiDualEncInstance *actual_instance;
+  	
+  
+  	
+  if (G_UNLIKELY (templ->direction != GST_PAD_SINK)) {
+    g_warning ("base_video_dualencoder: request pad that is not a SINK pad");
+    return NULL;
+  }
+  
+  /*if(!(templ == gst_element_class_get_pad_template (klass, "sink"))) {
+	GST_WARNING ("This is not our template!");
+	return NULL; 
+  }*/
+  
+  /* Determine the sink pad name */
+  if(NULL == base_dualencoder->low_resolution_encoder->collect) {
+	 pad_name = "sinkA";
+	 //src_pad_name =  "srcA";
+	 actual_instance = base_dualencoder->low_resolution_encoder; 
+  }
+  else if(NULL == base_dualencoder->high_resolution_encoder->collect) {
+	 pad_name = "sinkB";
+	 //src_pad_name =  "srcB";
+	 actual_instance = base_dualencoder->high_resolution_encoder;
+  }
+  else {
+	 GST_WARNING ("Can't determine the pad name or number of request is more than 2!");
+	 return NULL;
+  }
+	
+  /* Get the pad and set it*/
+  new_sink_pad = gst_tidmai_base_video_dualencoder_construct_pad(video_dualencoder, pad_name);
+  actual_instance->collect = gst_collect_pads_add_pad (base_dualencoder->collect_sink_pads,  new_sink_pad,
+                                                         sizeof(GstCollectData));
+  gst_pad_set_setcaps_function(
+        new_sink_pad, GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_sink_set_caps));
+  //actual_instance->src_pad = gst_tidmai_base_video_dualencoder_construct_pad(video_dualencoder, src_pad_name);
+  
+  /* Add the pads to the dualencoder element */		
+  gst_element_add_pad (element, new_sink_pad);
+  gst_child_proxy_child_added (GST_OBJECT (element), GST_OBJECT (new_sink_pad));
+  
+  //gst_element_add_pad (element, actual_instance->src_pad);
+  
+  
+  return new_sink_pad;
+
+}
+
+static void
+gst_tidmai_base_video_dualencoder_class_init (GstTIDmaiBaseVideoDualEncoderClass *
+    video_dualencoder_class)
+{
+  GObjectClass *gobject_class = (GObjectClass *) video_dualencoder_class;
+	
+  /* Init debug instance */
+  GST_DEBUG_CATEGORY_INIT (gst_tidmai_base_video_dualencoder_debug,
+      "tidmaibasevideodualencoder", 0, "CodecEngine base video dualencoder Class");
+
+  GST_DEBUG ("ENTER");
+
+  /* Instance the class methods */
+  video_dualencoder_class->video_dualencoder_realize_instance =
+      GST_DEBUG_FUNCPTR (gst_tidmai_base_video_dualencoder_default_realize_instance);
+  video_dualencoder_class->video_dualencoder_sink_get_caps =
+      GST_DEBUG_FUNCPTR (gst_tidmai_base_video_dualencoder_default_sink_get_caps);
+
+  /* Override heredity methods */
+  gobject_class->set_property = gst_tidmai_base_video_dualencoder_set_property;
+  gobject_class->get_property = gst_tidmai_base_video_dualencoder_get_property;
+  gobject_class->finalize = GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_finalize);
+  
+  GST_DEBUG ("LEAVE");
+}
+
+
+static void
+gst_tidmai_base_video_dualencoder_init (GstTIDmaiBaseVideoDualEncoder * video_dualencoder,
+    GstTIDmaiBaseVideoDualEncoderClass * video_dualencoder_class)
+{ 
+  
+  GST_DEBUG_OBJECT (video_dualencoder, "Entry _init video dualencoder");
+  GstTIDmaiBaseDualEncoder *base_dualencoder = GST_TI_DMAI_BASE_DUALENCODER(video_dualencoder);
+  
+  /* Set the function that is call when all the pads have buffer */
+  gst_collect_pads_set_function (base_dualencoder->collect_sink_pads,
+      (GstCollectPadsFunction) GST_DEBUG_FUNCPTR (gst_tidmai_base_video_dualencoder_entry_buffers_collected),
+      video_dualencoder);
+  
+  /* Init the mutex for the set_caps */
+  video_dualencoder->set_caps_mutex = g_malloc0(sizeof(GMutex));
+  g_mutex_init(video_dualencoder->set_caps_mutex);
+  
+  GST_DEBUG_OBJECT (video_dualencoder, "Leave _init video dualencoder");
+
+}
+
+
+/* Obtain and register the type of the class */
+GType
+gst_tidmai_base_video_dualencoder_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (object_type == 0) {
+    static const GTypeInfo object_info = {
+      sizeof (GstTIDmaiBaseVideoDualEncoderClass),
+      (GBaseInitFunc) gst_tidmai_base_video_dualencoder_base_init,
+      (GBaseFinalizeFunc) gst_tidmai_base_video_dualencoder_base_finalize,
+      (GClassInitFunc) gst_tidmai_base_video_dualencoder_class_init,
+      NULL,
+      NULL,
+      sizeof (GstTIDmaiBaseVideoDualEncoder),
+      0,
+      (GInstanceInitFunc) gst_tidmai_base_video_dualencoder_init,
+      NULL
+    };
+
+    object_type = g_type_register_static (GST_TYPE_TI_DMAI_BASE_DUALENCODER,
+        "GstTIDmaiBaseVideoDualEncoder", &object_info, (GTypeFlags) 0);
+  }
+  return object_type;
+};
Index: gst-dmai-plugins/src/src/gsttidmaibasevideodualencoder.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaibasevideodualencoder.h	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,115 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifndef ___GST_TI_DMAI_BASE_VIDEO_DUALENCODER_H__
+#define ___GST_TI_DMAI_BASE_VIDEO_DUALENCODER_H__
+
+#include <gst/gst.h>
+#include <ti/sdo/dmai/ColorSpace.h>
+#include "gsttidmaibasedualencoder.h"
+#include <gst/base/gstcollectpads.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER \
+  (gst_tidmai_base_video_dualencoder_get_type())
+#define GST_TI_DMAI_BASE_VIDEO_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER,GstTIDmaiBaseVideoDualEncoder))
+#define GST_TI_DMAI_BASE_VIDEO_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER,GstTIDmaiBaseVideoDualEncoderClass))
+#define GST_IS_TI_DMAI_BASE_VIDEO_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER))
+#define GST_IS_TI_DMAI_BASE_VIDEO_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER))
+#define GST_TI_DMAI_BASE_VIDEO_DUALENCODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER, GstTIDmaiBaseVideoDualEncoderClass))
+typedef struct _GstTIDmaiBaseVideoDualEncoder GstTIDmaiBaseVideoDualEncoder;
+typedef struct _GstTIDmaiBaseVideoDualEncoderClass GstTIDmaiBaseVideoDualEncoderClass;
+typedef struct _GstTIDmaiVideoInfo GstTIDmaiVideoInfo;
+
+/**
+ * This is the base class for the CodecEngine based video dualencoders
+ * @extends _GstTIDmaiBaseDualEncoder
+ */
+struct _GstTIDmaiBaseVideoDualEncoder
+{ 
+  GstTIDmaiBaseDualEncoder base_dualencoder;
+  
+  /* Mutex for control the acces to set_caps function */
+  GMutex *set_caps_mutex;
+  
+};
+
+
+struct _GstTIDmaiVideoInfo
+{
+  gint framerateN;
+  gint framerateD;
+  gint height;
+  gint width;
+  gint pitch;
+  ColorSpace_Type colorSpace;
+};
+
+struct _GstTIDmaiBaseVideoDualEncoderClass
+{
+  GstTIDmaiBaseDualEncoderClass parent_class;
+
+  GstFlowReturn (*video_dualencoder_realize_instance) (GstTIDmaiBaseVideoDualEncoder *video_dualencoder,
+	GstTIDmaiDualEncInstance *encoder_instance, GstBuffer *entry_buffer);
+  GstCaps *(*video_dualencoder_sink_get_caps) (GstPad * pad, GstCaps * filter);
+  GstPad *(*video_dualencoder_construct_pad) (const gchar *name);
+};
+
+GType gst_tidmai_base_video_dualencoder_get_type (void);
+
+
+/*---------------------*/
+/* Protected Functions */
+/*---------------------*/
+
+#define gst_tidmai_base_video_dualencoder_construct_pad(obj, name) \
+  GST_TI_DMAI_BASE_VIDEO_DUALENCODER_GET_CLASS(obj)->video_dualencoder_construct_pad(name)
+
+#define gst_tidmai_base_video_dualencoder_realize_instance(obj, instance, buf) \
+  GST_TI_DMAI_BASE_VIDEO_DUALENCODER_GET_CLASS(obj)->video_dualencoder_realize_instance(obj, instance , buf)
+
+#define gst_tidmai_base_video_dualencoder_sink_get_caps(obj, pad, filter) \
+  GST_TI_DMAI_BASE_VIDEO_DUALENCODER_GET_CLASS(obj)->video_dualencoder_sink_get_caps(pad, filter)
+
+/*-------------------*/
+/* Public methods */
+/*-------------------*/
+
+gboolean 
+gst_tidmai_base_video_dualencoder_sink_event(GstPad *pad, GstEvent *event);
+
+gboolean 
+gst_tidmai_base_video_dualencoder_sink_set_caps (GstPad * pad, GstCaps * caps);
+
+GstPad *
+gst_tidmai_base_video_dualencoder_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * req_name);
+	
+GstFlowReturn
+gst_tidmai_base_video_dualencoder_entry_buffers_collected (GstCollectPads * pads, 
+	GstTIDmaiBaseVideoDualEncoder * video_dualencoder);
+
+
+/* Abstract Functions */
+
+G_END_DECLS
+#endif /* ___GST_BASE_TI_DMAI_VIDEO_DUALENCODER_H__ */
Index: gst-dmai-plugins/src/src/gsttidmaih264dualencoder.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaih264dualencoder.c	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,815 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "gsttidmaih264dualencoder.h"
+#include "gsttidmaibuffertransport.h"
+
+#include <string.h>
+#include <gst/gst.h>
+#include <ti/sdo/codecs/h264enc/ih264venc.h>
+#include <ti/sdo/dmai/Buffer.h>
+
+
+GST_DEBUG_CATEGORY_STATIC (tidmaienc_h264);
+#define GST_CAT_DEFAULT tidmaienc_h264
+#define NO_PPS -1
+#define NO_SPS -2
+#define NO_PPS_SPS -3
+#define NAL_LENGTH 4
+#define GENERATE_METADATA 1
+#define CONSUME_METADATA 2
+
+
+static void gst_tidmai_h264_dualencoder_finalize (GObject * object);
+
+
+/* Especification of the statics caps for h264 dualencoder */
+static GstStaticPadTemplate gst_tidmai_h264_dualencoder_sink_factory =
+    GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (
+        "video/x-raw-yuv, "
+			"format=(fourcc)NV12,"
+			"width = (int) [ 1, MAX ],"
+			"height = (int) [ 1, MAX ],"
+			"framerate=(fraction)[ 0, MAX ];"
+    )
+    );
+
+static GstStaticPadTemplate gst_tidmai_h264_dualencoder_src_factory =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-h264, "
+						"stream-format = (string) avc,"
+						"width = (int) [ 1, MAX ],"
+						"height = (int) [ 1, MAX ],"
+						"framerate=(fraction)[ 0, MAX ];"
+	)
+    );
+
+enum
+{
+  PROP_75=75,
+  PROP_FORCEINTRA,
+};
+
+
+
+/******************************************************************************
+ * gst_tidmai_h264_dualencoder_finalize
+ *****************************************************************************/
+static void gst_tidmai_h264_dualencoder_finalize (GObject * object)
+{
+    GstTIDmaiH264DualEncoder *h264_dualencoder = (GstTIDmaiH264DualEncoder *)object;
+    
+	gst_buffer_unref(h264_dualencoder->chrominance_buffer);
+
+    G_OBJECT_CLASS(g_type_class_peek_parent(G_OBJECT_GET_CLASS (object)))
+        ->finalize (object);
+}
+
+
+
+
+/* base_init of the class */
+static void
+gst_tidmai_h264_dualencoder_base_init (GstTIDmaiH264DualEncoderClass * klass)
+{
+	
+	 GstElementClass *element_class = GST_ELEMENT_CLASS(klass);
+	 static GstElementDetails details;
+	
+	
+	details.longname = g_strdup_printf ("DMAI h264 dual-enc");
+    details.klass = g_strdup_printf ("Codec/Encoder/DualEncoder");
+    details.description = g_strdup_printf ("DMAI dual-encoder");
+      details.author = "Luis Arce; RidgeRun Engineering ";
+					   
+	gst_element_class_set_details(element_class, &details);
+}
+
+/* base finalize for the class */
+static void
+gst_tidmai_h264_dualencoder_base_finalize (GstTIDmaiH264DualEncoderClass * klass)
+{
+}
+
+
+/* Implementation of fix_src_caps depending of template src caps 
+ * and src_peer caps */
+GstCaps *
+gst_tidmai_h264_dualencoder_fixate_src_caps (GstTIDmaiBaseVideoDualEncoder * base_video_dualencoder,
+    GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  //g_print("Entry gst_tidmai_h264_dualencoder_fixate_src_caps\n");
+  GstTIDmaiH264DualEncoder *h264_dualencoder = GST_TI_DMAI_H264_DUALENCODER (base_video_dualencoder);
+
+  GstCaps *caps, *othercaps;
+
+  GstStructure *structure;
+  const gchar *stream_format;
+
+  GstTIDmaiVideoInfo *video_info;
+	
+  GST_DEBUG_OBJECT (h264_dualencoder, "Enter fixate_src_caps h264 dualencoder");
+
+  video_info = (GstTIDmaiVideoInfo *) encoder_instance->media_info;
+
+  /* Obtain the intersec between the src_pad and this peer caps */
+  othercaps = gst_pad_get_allowed_caps(encoder_instance->src_pad); 
+
+  if (othercaps == NULL ||
+      gst_caps_is_empty (othercaps) || gst_caps_is_any (othercaps)) {
+    /* If we got nothing useful, user our template caps */
+    caps =
+        gst_caps_copy (gst_pad_get_pad_template_caps (encoder_instance->src_pad));
+  } else {
+    /* We got something useful */
+    caps = othercaps;
+  }
+  
+ 
+  /* Ensure that the caps are writable */
+  caps = gst_caps_make_writable (caps);
+
+
+  structure = gst_caps_get_structure (caps, 0);
+  if (structure == NULL) {
+    GST_ERROR_OBJECT (base_video_dualencoder, "Failed to get src caps structure");
+    return NULL;
+  }
+  /* Force to use avc and nal in case of null */
+  stream_format = gst_structure_get_string (structure, "stream-format");
+  if (stream_format == NULL) {
+    stream_format = "avc";
+    gst_structure_set (structure, "stream-format", G_TYPE_STRING, stream_format, (char *)NULL);
+  }
+  
+  /* Set the width, height and framerate */
+  gst_structure_set (structure, "width", G_TYPE_INT,
+      video_info->width, (char *)NULL);
+  gst_structure_set (structure, "height", G_TYPE_INT, video_info->height, (char *)NULL);
+  gst_structure_set (structure, "framerate", GST_TYPE_FRACTION, video_info->framerateN,
+      video_info->framerateD, (char *)NULL);
+  
+  /* Save the specific decision for future use */
+  h264_dualencoder->generate_bytestream =
+      !strcmp (stream_format, "byte-stream") ? TRUE : FALSE;
+	
+  
+  GST_DEBUG_OBJECT (h264_dualencoder, "Leave fixate_src_caps h264 dualencoder");
+  return caps;
+}
+
+/* Init of the class */
+static void
+gst_tidmai_h264_dualencoder_init (GstTIDmaiH264DualEncoder * h264_dualencoder)
+{
+
+
+  /* Obtain base class and instance */
+  GstTIDmaiBaseDualEncoder *base_dualencoder = GST_TI_DMAI_BASE_DUALENCODER (h264_dualencoder);
+
+
+  GST_DEBUG_OBJECT (h264_dualencoder, "ENTER");
+  
+  GstPad *sinkA = NULL;
+  GstPad *sinkB = NULL;
+  
+  /* Init the chrominance */
+  h264_dualencoder->chrominance_buffer = gst_buffer_new();
+  
+  /* Process the src caps */
+  base_dualencoder->low_resolution_encoder->src_pad = 
+	gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_src_factory,
+      "srcA");
+  gst_element_add_pad (GST_ELEMENT(base_dualencoder), base_dualencoder->low_resolution_encoder->src_pad);
+	 
+  base_dualencoder->high_resolution_encoder->src_pad = 
+	gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_src_factory,
+      "srcB");
+  gst_element_add_pad (GST_ELEMENT(base_dualencoder), base_dualencoder->high_resolution_encoder->src_pad);
+  
+  /* Process the sinkpad */
+  sinkA = gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_sink_factory,
+			"sinkA");
+  base_dualencoder->low_resolution_encoder->collect = 
+	gst_collect_pads_add_pad (base_dualencoder->collect_sink_pads,  sinkA,
+                               sizeof(GstCollectData));
+   gst_pad_set_setcaps_function(
+        sinkA, GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_sink_set_caps));	
+  gst_element_add_pad (GST_ELEMENT (base_dualencoder), sinkA);
+  
+  gst_pad_set_event_function(
+        sinkA, GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_sink_event));
+  
+  
+  sinkB = gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_sink_factory,
+			"sinkB");
+  base_dualencoder->high_resolution_encoder->collect = 
+	gst_collect_pads_add_pad (base_dualencoder->collect_sink_pads,  sinkB,
+                               sizeof(GstCollectData));
+  gst_pad_set_setcaps_function(
+        sinkB, GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_sink_set_caps));
+  gst_element_add_pad (GST_ELEMENT (base_dualencoder), sinkB);
+  
+  gst_pad_set_event_function(
+        sinkB, GST_DEBUG_FUNCPTR(gst_tidmai_base_video_dualencoder_sink_event));	
+	
+  /* Setup codec name */
+  base_dualencoder->codec_name = "h264enc";
+  
+  h264_dualencoder->alloc_extend_dyn_params = FALSE;
+  
+  
+  GST_DEBUG_OBJECT (h264_dualencoder, "LEAVE");
+
+}
+
+/* Set properties own from the h264 format */
+static void
+gst_tidmai_h264_dualencoder_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+
+  VIDENC1_DynamicParams *dynamic_params =
+      GST_TI_DMAI_BASE_DUALENCODER (object)->codec_dynamic_params;
+
+  switch (prop_id) {
+    case PROP_FORCEINTRA:
+      dynamic_params->forceFrame =
+          g_value_get_boolean (value) ? IVIDEO_IDR_FRAME : IVIDEO_NA_FRAME;
+      break;
+    default:
+      break;
+  }
+}
+
+/* Get properties own from the h264 format */
+static void
+gst_tidmai_h264_dualencoder_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  VIDENC1_DynamicParams *dynamic_params =
+      GST_TI_DMAI_BASE_DUALENCODER (object)->codec_dynamic_params;
+  switch (prop_id) {
+    case PROP_FORCEINTRA:
+	  if(dynamic_params->forceFrame == IVIDEO_NA_FRAME) {
+	    g_value_set_boolean (value, FALSE);	  
+	  }
+	  else {
+	    g_value_set_boolean (value, TRUE);	 
+	  }
+      break;
+    default:
+      break;
+  }
+}
+
+/* Install properties own from h264 format  */
+void
+gst_tidmai_h264_install_properties (GObjectClass * gobject_class)
+{
+
+  g_object_class_install_property (gobject_class, PROP_FORCEINTRA,
+      g_param_spec_boolean ("forceintra",
+          "Force next frame to be an intracodec frame",
+          "Force next frame to be an intracodec frame",
+          FALSE, G_PARAM_READWRITE));
+}
+
+/* Seach for PPS and SPS */
+GstBuffer*
+gst_tidmai_h264_dualencoder_fetch_nal(GstBuffer *buffer, gint type)
+{
+    
+	gint i;
+    guchar *data = GST_BUFFER_DATA(buffer);
+    GstBuffer *nal_buffer;
+    gint nal_idx = 0;
+    gint nal_len = 0;
+    gint nal_type = 0;
+    gint found = 0;
+    gint done = 0;
+
+    GST_DEBUG("Fetching NAL, type %d", type);
+    for (i = 0; i < GST_BUFFER_SIZE(buffer) - 5; i++) {
+        if (data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 0
+            && data[i + 3] == 1) {
+            if (found == 1) {
+                nal_len = i - nal_idx;
+                done = 1;
+                break;
+            }
+
+            nal_type = (data[i + 4]) & 0x1f;
+            if (nal_type == type)
+            {
+                found = 1;
+                nal_idx = i + 4;
+                i += 4;
+            }
+        }
+    }
+
+    /* Check if the NAL stops at the end */
+    if (found == 1 && done != 0 && i >= GST_BUFFER_SIZE(buffer) - 4) {
+        nal_len = GST_BUFFER_SIZE(buffer) - nal_idx;
+        done = 1;
+    }
+
+    if (done == 1) {
+        GST_DEBUG("Found NAL, bytes [%d-%d] len [%d]", nal_idx, nal_idx + nal_len - 1, nal_len);
+        nal_buffer = gst_buffer_new_and_alloc(nal_len);
+        memcpy(GST_BUFFER_DATA(nal_buffer),&data[nal_idx],nal_len);
+        return nal_buffer;
+    } else {
+        GST_DEBUG("Did not find NAL type %d", type);
+        return NULL;
+    }
+}
+
+
+
+
+
+/* Function that generate the codec data, with the SPS and PPS as input */
+GstBuffer *
+gst_tidmai_h264_dualencoder_generate_codec_data(GstTIDmaiH264DualEncoder *h264_dualencoder, GstBuffer *buffer) {
+  
+    GstBuffer *avcc = NULL;
+    guchar *avcc_data = NULL;
+    gint avcc_len = 7;  // Default 7 bytes w/o SPS, PPS data
+    gint i;
+
+    GstBuffer *sps = NULL;
+    guchar *sps_data = NULL;
+    gint num_sps=0;
+
+    GstBuffer *pps = NULL;
+    gint num_pps=0;
+
+    guchar profile;
+    guchar compatibly;
+    guchar level;
+
+    sps = gst_tidmai_h264_dualencoder_fetch_nal(buffer, 7); // 7 = SPS
+    if (sps){
+        num_sps = 1;
+        avcc_len += GST_BUFFER_SIZE(sps) + 2;
+        sps_data = GST_BUFFER_DATA(sps);
+
+        profile     = sps_data[1];
+        compatibly  = sps_data[2];
+        level       = sps_data[3];
+
+        GST_DEBUG("SPS: profile=%d, compatibly=%d, level=%d",
+                    profile, compatibly, level);
+    } else {
+        GST_WARNING("No SPS found");
+
+        profile     = 66;   // Default Profile: Baseline
+        compatibly  = 0;
+        level       = 30;   // Default Level: 3.0
+    }
+    pps = gst_tidmai_h264_dualencoder_fetch_nal(buffer, 8); // 8 = PPS
+    if (pps){
+        num_pps = 1;
+        avcc_len += GST_BUFFER_SIZE(pps) + 2;
+    }
+
+    avcc = gst_buffer_new_and_alloc(avcc_len);
+    avcc_data = GST_BUFFER_DATA(avcc);
+    avcc_data[0] = 1;               // [0] 1 byte - version
+    avcc_data[1] = profile;       // [1] 1 byte - h.264 stream profile
+    avcc_data[2] = compatibly;    // [2] 1 byte - h.264 compatible profiles
+    avcc_data[3] = level;         // [3] 1 byte - h.264 stream level
+    avcc_data[4] = 0xfc | (NAL_LENGTH-1);  // [4] 6 bits - reserved all ONES = 0xfc
+                                  // [4] 2 bits - NAL length ( 0 - 1 byte; 1 - 2 bytes; 3 - 4 bytes)
+    avcc_data[5] = 0xe0 | num_sps;// [5] 3 bits - reserved all ONES = 0xe0
+                                  // [5] 5 bits - number of SPS
+    i = 6;
+    if (num_sps > 0){
+        avcc_data[i++] = GST_BUFFER_SIZE(sps) >> 8;
+        avcc_data[i++] = GST_BUFFER_SIZE(sps) & 0xff;
+        memcpy(&avcc_data[i],GST_BUFFER_DATA(sps),GST_BUFFER_SIZE(sps));
+        i += GST_BUFFER_SIZE(sps);
+    }
+    avcc_data[i++] = num_pps;      // [6] 1 byte  - number of PPS
+    if (num_pps > 0){
+        avcc_data[i++] = GST_BUFFER_SIZE(pps) >> 8;
+        avcc_data[i++] = GST_BUFFER_SIZE(pps) & 0xff;
+        memcpy(&avcc_data[i],GST_BUFFER_DATA(pps),GST_BUFFER_SIZE(pps));
+        i += GST_BUFFER_SIZE(sps);
+    }
+
+    return avcc;
+}
+
+/* Alloc the extends params for indicate the type of behavior for the codec instance */
+void 
+gst_tidmai_h264_dualencoder_alloc_extend_params(GstTIDmaiBaseDualEncoder * base_dualencoder) {
+	
+	IH264VENC_DynamicParams *h264_dynParams;
+	VIDENC1_DynamicParams *codec_dynamic_params = (VIDENC1_DynamicParams *)base_dualencoder->codec_dynamic_params;
+	
+	/* Set the size for indicate that are extend */
+	codec_dynamic_params->size = sizeof(IH264VENC_DynamicParams);
+	
+	/* Alloc the params and set a default value */
+	h264_dynParams = g_malloc0(sizeof(IH264VENC_DynamicParams));
+	*h264_dynParams = H264VENC_TI_IH264VENC_DYNAMICPARAMS;
+	
+	/* Add the extends params to the original params */
+	h264_dynParams->videncDynamicParams = *codec_dynamic_params;
+	base_dualencoder->codec_dynamic_params = (VIDENC1_DynamicParams *)h264_dynParams;
+	
+}
+
+
+/* Set the extend params for permit to consume or generate metadata for the codec instance */
+void 
+gst_tidmai_h264_dualencoder_set_extend_params(GstTIDmaiBaseDualEncoder * base_dualencoder, gint set_type, GstTIDmaiDualEncInstance *encoder_instance) {
+	
+	VIDENC1_Status encStatus;
+	Buffer_Attrs mvsad_Attrs;
+	Buffer_Attrs MBinfo_Attrs;
+	Buffer_Attrs MBRowinfo_Attrs;
+	Buffer_Attrs frameInfo_Attrs;
+  	
+	Buffer_Handle mvsad_buffer_handle;
+	Buffer_Handle MBinfo_handle;
+	Buffer_Handle MBRowinfo_handle;
+	Buffer_Handle frameInfo_buffer_handle;
+	GstTIDmaiVideoInfo *video_info = (GstTIDmaiVideoInfo *)encoder_instance->media_info;
+	
+	/* Set the standard dinamic params with the values of the actual codec instance */
+	gst_tidmai_videnc1_initialize_params (base_dualencoder, encoder_instance);
+	
+	/* Set the extends params fields */
+	IH264VENC_DynamicParams *h264_dynParams = (IH264VENC_DynamicParams *) base_dualencoder->codec_dynamic_params;
+	h264_dynParams->metaDataGenerateConsume = set_type;
+	
+	if(set_type == GENERATE_METADATA) {
+		h264_dynParams->mvSADoutFlag = 1;
+	}
+	else {
+		h264_dynParams->mvSADoutFlag = 0;
+	} 
+	
+	/* Check for the metadata buffer  */
+    if(NULL == base_dualencoder->frameInfo) {
+	
+	  	/* Obtain the size of the buffer for the metadata */
+	if (!gst_tidmai_videnc1_control (base_dualencoder, encoder_instance, XDM_GETBUFINFO, &encStatus)) {
+		GST_WARNING ("Problems for obtain the sizes of the out buffers");
+    }
+	
+	mvsad_Attrs = Buffer_Attrs_DEFAULT;
+	MBinfo_Attrs = Buffer_Attrs_DEFAULT;
+	MBRowinfo_Attrs = Buffer_Attrs_DEFAULT;
+	frameInfo_Attrs = Buffer_Attrs_DEFAULT;
+
+	mvsad_buffer_handle = Buffer_create(encStatus.bufInfo.minOutBufSize[1], &mvsad_Attrs);
+	MBinfo_handle = Buffer_create(((video_info->height * video_info->width) >> 4) * 4, 
+									&MBinfo_Attrs); /* size: (max-num-pixels-in-frame >> 4) * 4 */
+	MBRowinfo_handle = Buffer_create(video_info->height * 4, 
+	                                &MBRowinfo_Attrs); /* size: heigh-in-pixels * 4  */
+	frameInfo_buffer_handle = Buffer_create(encStatus.bufInfo.minOutBufSize[2], &frameInfo_Attrs);
+		  
+	base_dualencoder->motionVector = gst_tidmaibuffertransport_new(mvsad_buffer_handle, NULL, NULL);
+	base_dualencoder->MBinfo = gst_tidmaibuffertransport_new(MBinfo_handle, NULL, NULL);
+	base_dualencoder->MBRowInfo = gst_tidmaibuffertransport_new(MBRowinfo_handle, NULL, NULL);
+	base_dualencoder->frameInfo = gst_tidmaibuffertransport_new(frameInfo_buffer_handle, NULL, NULL);
+   }	
+		
+	/* Set the params in the codec instance */
+	if (!gst_tidmai_videnc1_control (base_dualencoder, encoder_instance, XDM_SETPARAMS, &encStatus)) {
+		GST_WARNING ("Problems for set extend params");
+    }	
+}
+
+/* Prepare the Inputs and Outputs buffers for the actual codec instance */
+GList *
+ gst_tidmai_h264_dualencoder_prepare_buffers(GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstBuffer * input_buffer, GstBuffer * output_buffer, GstTIDmaiDualEncInstance *encoder_instance) {
+	
+	GList *inOut_buffers = NULL;
+	GList *input_buffers = NULL;
+	GList *output_buffers = NULL;
+	IH264VENC_DynamicParams *h264_dynParams = (IH264VENC_DynamicParams *) base_dualencoder->codec_dynamic_params;
+	GstTIDmaiH264DualEncoder *h264_dualencoder = GST_TI_DMAI_H264_DUALENCODER(base_dualencoder);
+	FrameInfo_Interface *metadata;
+	
+	/* Prepare the chrominance buffer (can be different depend of the mimetype) */
+	GST_BUFFER_SIZE (h264_dualencoder->chrominance_buffer) = GST_BUFFER_SIZE (input_buffer);
+	GST_BUFFER_MALLOCDATA (h264_dualencoder->chrominance_buffer) = GST_BUFFER_DATA(input_buffer) + 
+		(GST_BUFFER_SIZE (input_buffer) * 2/3);
+	GST_BUFFER_DATA (h264_dualencoder->chrominance_buffer) = GST_BUFFER_MALLOCDATA (h264_dualencoder->chrominance_buffer);
+	
+	/* Add minimum input and output buffer */
+	input_buffers = g_list_append(input_buffers, input_buffer);
+	input_buffers = g_list_append(input_buffers, h264_dualencoder->chrominance_buffer);
+    output_buffers = g_list_append(output_buffers, output_buffer);
+	
+	switch (h264_dynParams->metaDataGenerateConsume) {
+		case GENERATE_METADATA:	
+		  /* Three extra buffers of output for the metadata generate */
+		  output_buffers = g_list_append(output_buffers, base_dualencoder->motionVector);
+		  output_buffers = g_list_append(output_buffers, base_dualencoder->MBinfo);
+		  output_buffers = g_list_append(output_buffers, base_dualencoder->MBRowInfo);
+		  output_buffers = g_list_append(output_buffers, base_dualencoder->frameInfo);
+		  break;
+		case CONSUME_METADATA:
+		  /* Prepare the metadata buffer */
+		  metadata = (FrameInfo_Interface *) GST_BUFFER_DATA(base_dualencoder->frameInfo);
+		  metadata->mvSADpointer =  (XDAS_Int32 *)GST_BUFFER_DATA(base_dualencoder->motionVector);
+		  metadata->mbComplexity = (XDAS_Int32 *)GST_BUFFER_DATA(base_dualencoder->MBinfo);
+		  metadata->gmvPointerVert = (XDAS_Int32 *)GST_BUFFER_DATA(base_dualencoder->MBRowInfo);
+		  
+		  /*One extra buffer of input for the metada consume */
+		  input_buffers = g_list_append(input_buffers, base_dualencoder->frameInfo);  
+		  break; 
+		default:
+		  GST_WARNING_OBJECT(GST_TI_DMAI_H264_DUALENCODER (base_dualencoder), "Buffers can't be prepare adequately");
+		  break;
+	}
+	
+	/* Put the two lists together */
+	inOut_buffers = g_list_append(inOut_buffers, input_buffers);
+    inOut_buffers = g_list_append(inOut_buffers, output_buffers);
+	
+	
+	return inOut_buffers;
+}
+
+/* Function that override the pre process method of the base class */
+GList *
+gst_tidmai_h264_dualencoder_pre_process (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, GList ** actual_free_slice, 
+	GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  GST_DEBUG_OBJECT (GST_TI_DMAI_H264_DUALENCODER (base_dualencoder), "Entry");
+  
+  GList *inOut_buffers = NULL;	
+  GstBuffer *output_buffer;
+  GstTIDmaiH264DualEncoder *h264_dualencoder = GST_TI_DMAI_H264_DUALENCODER(base_dualencoder);
+  
+  
+  if(FALSE == h264_dualencoder->alloc_extend_dyn_params)  {
+	gst_tidmai_h264_dualencoder_alloc_extend_params(base_dualencoder); 
+	h264_dualencoder->alloc_extend_dyn_params = TRUE;
+  }
+  
+  /* Init the extend params depends of the class of instance */
+  if(encoder_instance == base_dualencoder->low_resolution_encoder) {
+	gst_tidmai_h264_dualencoder_set_extend_params(base_dualencoder, GENERATE_METADATA, encoder_instance);
+  }
+  else {
+	gst_tidmai_h264_dualencoder_set_extend_params(base_dualencoder, CONSUME_METADATA, encoder_instance);
+  }
+  
+  /* Obtain the slice of the output buffer to use */
+  output_buffer =
+      gst_tidmai_base_dualencoder_get_output_buffer (base_dualencoder, actual_free_slice, encoder_instance);
+
+  GST_DEBUG_OBJECT (GST_TI_DMAI_H264_DUALENCODER (base_dualencoder), "Leave");
+
+  /* Prepare the list of output and input buffers */
+  inOut_buffers = gst_tidmai_h264_dualencoder_prepare_buffers(base_dualencoder, 
+	buffer, output_buffer, encoder_instance);
+
+  return inOut_buffers;
+}
+
+
+/* Function for convert the content of the buffer from bytestream to packetized convertion */
+GstBuffer* 
+gst_tidmai_h264_dualencoder_to_packetized(GstBuffer *out_buffer) {
+	
+	gint i, mark = 0, nal_type = -1;
+    gint size = GST_BUFFER_SIZE(out_buffer);
+    guchar *dest;
+	
+	dest = GST_BUFFER_DATA(out_buffer);
+	
+	for (i = 0; i < size - 4; i++) {
+        if (dest[i] == 0 && dest[i + 1] == 0 &&
+            dest[i+2] == 0 && dest[i + 3] == 1) {
+            /* Do not copy if current NAL is nothing (this is the first start code) */
+            if (nal_type == -1) {
+                nal_type = (dest[i + 4]) & 0x1f;
+            } else if (nal_type == 7 || nal_type == 8) {
+                /* Discard anything previous to the SPS and PPS */
+                GST_BUFFER_DATA(out_buffer) = &dest[i];
+                GST_BUFFER_SIZE(out_buffer) = size - i;
+                
+            } else {
+                /* Replace the NAL start code with the length */
+                gint length = i - mark ;
+                gint k;
+                for (k = 1 ; k <= 4; k++){
+                    dest[mark - k] = length & 0xff;
+                    length >>= 8;
+                }
+
+                nal_type = (dest[i + 4]) & 0x1f;
+            }
+            /* Mark where next NALU starts */
+            mark = i + 4;
+
+            nal_type = (dest[i + 4]) & 0x1f;
+        }
+    }
+    if (i == (size - 4)){
+        /* We reach the end of the buffer */
+        if (nal_type != -1){
+            /* Replace the NAL start code with the length */
+            gint length = size - mark ;
+            gint k;
+            for (k = 1 ; k <= 4; k++){
+                dest[mark - k] = length & 0xff;
+                length >>= 8;
+            }
+        }
+    }
+	
+	//g_print("DEBUG %s %d\n", __FILE__, __LINE__);
+		
+    return out_buffer;
+	
+}
+
+
+/* Function that override the post process method of the base class */
+GstBuffer *
+gst_tidmai_h264_dualencoder_post_process (GstTIDmaiBaseDualEncoder *base_dualencoder,
+    GList * buffers, GList ** actual_free_slice, GstTIDmaiDualEncInstance *encoder_instance) {
+  
+  GstBuffer *codec_data;
+  gboolean set_caps_ret;
+  GstCaps *caps;
+  
+  
+  /* For default, first buffer most be have the encode data */
+  GstBuffer *encoder_buffer = buffers->data;
+
+  /* Restore unused memory after encode */
+  gst_tidmai_base_dualencoder_restore_unused_memory (base_dualencoder, encoder_buffer,
+      actual_free_slice, encoder_instance);
+  
+  
+  if (base_dualencoder->first_buffer == FALSE) {
+	
+    /* fixate the caps */
+    caps =
+        gst_tidmai_h264_dualencoder_fixate_src_caps (GST_TI_DMAI_BASE_VIDEO_DUALENCODER
+        (base_dualencoder), encoder_instance);
+	
+    if (caps == NULL) {
+      GST_WARNING_OBJECT (GST_TI_DMAI_H264_DUALENCODER (base_dualencoder),
+          "Problems for fixate src caps");
+    }
+
+    /* Generate the codec data with the SPS and the PPS */
+    codec_data = gst_tidmai_h264_dualencoder_generate_codec_data(GST_TI_DMAI_H264_DUALENCODER (base_dualencoder), 
+					encoder_buffer);
+    
+    /* Update the caps with the codec data */
+    gst_caps_set_simple (caps, "codec_data", GST_TYPE_BUFFER, codec_data, (char *)NULL);
+    set_caps_ret = gst_pad_set_caps (encoder_instance->src_pad, caps);
+	if (set_caps_ret == FALSE) {
+      GST_WARNING_OBJECT (GST_TI_DMAI_H264_DUALENCODER (base_dualencoder),
+          "Src caps can't be update");
+    }
+	
+	gst_buffer_unref (codec_data);
+	
+	
+	/* Only if the actual encoder is high resolution */
+	if(encoder_instance == base_dualencoder->high_resolution_encoder) {
+		base_dualencoder->first_buffer = TRUE;
+	}
+	
+  }
+   
+   
+  /* Convert the buffer into packetizer */
+  encoder_buffer = gst_tidmai_h264_dualencoder_to_packetized(encoder_buffer); 
+   
+  return encoder_buffer;	
+
+}
+
+GstPad* 
+video_dualencoder_construct_pad (const gchar *name) {
+	GstPad *ret = NULL;
+	
+	/* sink pad or src pad */
+	if(strncmp("sink", name, 4) == 0) {
+		ret = gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_sink_factory,
+				name);
+	}
+	else if(strncmp("src", name, 3) == 0) {
+		ret = gst_pad_new_from_static_template (&gst_tidmai_h264_dualencoder_src_factory,
+				name);
+	}
+	else {
+		GST_WARNING("Invalid pad name for construct!");
+	}
+	
+	return ret;
+}
+
+
+/* class_init of the class */
+static void
+gst_tidmai_h264_dualencoder_class_init (GstTIDmaiH264DualEncoderClass * klass)
+{
+
+  /* Obtain base class */
+  GstTIDmaiBaseDualEncoderClass *base_dualencoder_class = GST_TI_DMAI_BASE_DUALENCODER_CLASS (klass);
+  GstTIDmaiBaseVideoDualEncoderClass *video_dualencoder_class = GST_TI_DMAI_BASE_VIDEO_DUALENCODER_CLASS(klass);
+  
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (tidmaienc_h264, "tidmaienc_h264", 0,
+      "CodecEngine h264 dualencoder");
+
+  GST_DEBUG ("ENTER");
+
+  /* Override of heredity functions */
+  base_dualencoder_class->base_dualencoder_pre_process =
+      gst_tidmai_h264_dualencoder_pre_process;
+  base_dualencoder_class->base_dualencoder_post_process =
+	  gst_tidmai_h264_dualencoder_post_process;
+  
+  video_dualencoder_class->video_dualencoder_construct_pad = 
+	  video_dualencoder_construct_pad;
+  gobject_class->set_property = gst_tidmai_h264_dualencoder_set_property;
+  gobject_class->get_property = gst_tidmai_h264_dualencoder_get_property;
+  gobject_class->finalize = GST_DEBUG_FUNCPTR(gst_tidmai_h264_dualencoder_finalize);
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_tidmai_h264_dualencoder_src_factory));
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&gst_tidmai_h264_dualencoder_sink_factory));
+
+  /* Install properties for the class */
+  gst_tidmai_h264_install_properties (gobject_class);
+
+  /*g_object_class_install_property (gobject_class, PROP_SINGLE_NAL,
+     g_param_spec_boolean ("single-nal", "Single NAL optimization",
+     "Assume dualencoder generates single NAL units per frame encoded to optimize avc stream generation",
+     FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)); */
+
+  GST_DEBUG ("LEAVE");
+}
+
+/* Obtain the type of the class */
+GType
+gst_tidmai_h264_dualencoder_get_type (void)
+{	
+  static GType object_type = 0;
+  if (object_type == 0) {
+    static const GTypeInfo object_info = {
+      sizeof (GstTIDmaiH264DualEncoderClass),
+      (GBaseInitFunc) gst_tidmai_h264_dualencoder_base_init,
+      (GBaseFinalizeFunc) gst_tidmai_h264_dualencoder_base_finalize,
+      (GClassInitFunc) gst_tidmai_h264_dualencoder_class_init,
+      NULL,
+      NULL,
+      sizeof (GstTIDmaiH264DualEncoder),
+      0,
+      (GInstanceInitFunc) gst_tidmai_h264_dualencoder_init,
+      NULL
+    };
+
+    object_type = g_type_register_static (GST_TYPE_TI_DMAI_VIDENC1,
+        "GstTIDmaiH264DualEncoder", &object_info, (GTypeFlags) 0);
+  }
+  return object_type;
+};
Index: gst-dmai-plugins/src/src/gsttidmaih264dualencoder.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaih264dualencoder.h	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,116 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifndef __GST_TI_DMAI_H264_DUALENCODER_H__
+#define __GST_TI_DMAI_H264_DUALENCODER_H__
+
+#include <gst/gst.h>
+
+#include "gsttidmaividenc1.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_TI_DMAI_H264_DUALENCODER \
+  (gst_tidmai_h264_dualencoder_get_type())
+#define GST_TI_DMAI_H264_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TI_DMAI_H264_DUALENCODER,GstTIDmaiH264DualEncoder))
+#define GST_TI_DMAI_H264_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TI_DMAI_H264_DUALENCODER,GstTIDmaiH264DualEncoderClass))
+#define GST_IS_TI_DMAI_H264_DUALENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TI_DMAI_H264_DUALENCODER))
+#define GST_IS_TI_DMAI_H264_DUALENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TI_DMAI_H264_DUALENCODER))
+#define GST_TI_DMAI_H264_DUALENCODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TI_DMAI_H264_DUALENCODER, GstTIDmaiH264DualEncoderClass))
+typedef struct _GstTIDmaiH264DualEncoder GstTIDmaiH264DualEncoder;
+typedef struct _GstTIDmaiH264DualEncoderClass GstTIDmaiH264DualEncoderClass;
+
+/**
+ * This class implements the video dualencoder for h264
+ * @extends _GstTIDmaiVIDENC1
+ */
+struct _GstTIDmaiH264DualEncoder
+{
+  GstTIDmaiVIDENC1 parent;
+
+  gboolean generate_aud;
+  gboolean generate_bytestream;
+  gboolean alloc_extend_dyn_params;
+  GstBuffer *chrominance_buffer;
+  
+  
+};
+
+struct _GstTIDmaiH264DualEncoderClass
+{
+  GstTIDmaiVIDENC1Class parent_class;
+
+};
+
+/* Macros that allow access to the methods of the class */
+
+/*-------------------*/
+/* Public methods ***/
+/*-------------------*/
+
+GList *
+gst_tidmai_h264_dualencoder_pre_process (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstBuffer * buffer, GList ** actual_free_slice, 
+	GstTIDmaiDualEncInstance *encoder_instance);
+
+
+GstBuffer *
+gst_tidmai_base_dualencoder_default_post_process (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GList * buffers, GList ** actual_free_slice, 
+	GstTIDmaiDualEncInstance *encoder_instance);
+	
+GstBuffer* 
+gst_tidmai_h264_dualencoder_to_packetized(GstBuffer *out_buffer);
+
+
+/* Auxiliar functions for the class
+ * Work similar to public methods  */
+
+
+GType gst_tidmai_h264_dualencoder_get_type (void);
+
+GstCaps *
+gst_tidmai_h264_dualencoder_fixate_src_caps (GstTIDmaiBaseVideoDualEncoder * base_video_dualencoder,
+    GstTIDmaiDualEncInstance *encoder_instance);
+
+GstBuffer*
+gst_tidmai_h264_dualencoder_fetch_nal(GstBuffer *buffer, gint type);
+    
+GstBuffer *
+gst_tidmai_h264_dualencoder_generate_codec_data(GstTIDmaiH264DualEncoder *h264_dualencoder, GstBuffer *buffer);
+    
+GstPad* 
+	video_dualencoder_construct_pad (const gchar *name);
+	
+void 
+gst_tidmai_h264_dualencoder_set_extend_params(GstTIDmaiBaseDualEncoder * base_dualencoder,
+	gint set_type, GstTIDmaiDualEncInstance *encoder_instance);
+
+void 
+gst_tidmai_h264_dualencoder_alloc_extend_params(GstTIDmaiBaseDualEncoder * base_dualencoder);
+
+GList *
+ gst_tidmai_h264_dualencoder_prepare_buffers(GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstBuffer * input_buffer, GstBuffer * output_buffer, GstTIDmaiDualEncInstance *encoder_instance);
+
+G_END_DECLS
+#endif /* __GST_TI_DMAI_H264_H__ */
Index: gst-dmai-plugins/src/src/gsttidmaividenc1.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaividenc1.c	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,569 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#include <gst/gst.h>
+#include "gsttidmaividenc1.h"
+#include "gsttidmaivideoutils.h"
+#include <ti/sdo/ce/utils/xdm/XdmUtils.h>
+#include <ti/sdo/ce/visa.c>
+#include <ti/sdo/ce/Engine.c>
+#include <ti/xdais/dm/ividenc1.h>
+
+
+
+#define GST_CAT_DEFAULT gst_tidmai_videnc1_debug
+GST_DEBUG_CATEGORY_STATIC (GST_CAT_DEFAULT);
+
+enum
+{
+  PROP_50=50,
+  PROP_RATECONTROL,
+  PROP_ENCODINGPRESET,
+  PROP_MAXBITRATE,
+  PROP_TARGETBITRATE,
+  PROP_INTRAFRAMEINTERVAL
+};
+
+
+
+static void
+gst_tidmai_videnc1_base_init (GstTIDmaiVIDENC1Class * klass)
+{
+}
+
+static void
+gst_tidmai_videnc1_base_finalize (GstTIDmaiVIDENC1Class * klass)
+{
+}
+
+/* Commands for the _control call of the codec instace */
+static const gchar *cmd_id_strings[] =
+    { "XDM_GETSTATUS", "XDM_SETPARAMS", "XDM_RESET", "XDM_SETDEFAULT",
+  "XDM_FLUSH", "XDM_GETBUFINFO", "XDM_GETVERSION", "XDM_GETCONTEXTINFO"
+};
+
+/* Implementation for the control function, 
+ * for obtain or set information of the codec instance after create it */
+gboolean
+gst_tidmai_videnc1_control (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance, gint cmd_id, VIDENC1_Status *encStatus)
+{
+  GST_DEBUG_OBJECT (GST_TI_DMAI_VIDENC1(base_dualencoder),
+      "ENTER videnc1_control with command: %s tidmaividenc1",
+      cmd_id_strings[cmd_id]);
+  if (encoder_instance->codec_handle != NULL) {
+    Int32 ret;
+    encStatus->size = sizeof (VIDENC1_Status);
+	
+	encStatus->data.buf = NULL;
+    
+
+    ret = VIDENC1_control (encoder_instance->codec_handle,
+        cmd_id,
+        (VIDENC1_DynamicParams *) base_dualencoder->codec_dynamic_params,
+        encStatus);
+
+    if (ret != VIDENC1_EOK) {
+      GST_WARNING_OBJECT (GST_TI_DMAI_VIDENC1(base_dualencoder),
+          "Failure run control cmd: %s, status error %x",
+          cmd_id_strings[cmd_id], (unsigned int) encStatus->extendedError);
+      return FALSE;
+    }
+  } else {
+    GST_WARNING_OBJECT (GST_TI_DMAI_VIDENC1(base_dualencoder),
+        "Not running control cmd since codec is not initialized");
+  }
+  GST_DEBUG_OBJECT (GST_TI_DMAI_VIDENC1(base_dualencoder), "LEAVE videnc1_control tidmaividenc1");
+  return TRUE;
+}
+
+
+
+/* Init the static and dynamic params for the codec instance */
+gboolean
+gst_tidmai_videnc1_initialize_params (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance)
+{
+  
+  GST_DEBUG ("Entry initialize_params tidmaividenc1");
+  
+  /* Access the dynamic and static params */
+  VIDENC1_Params *params = base_dualencoder->codec_params;
+  VIDENC1_DynamicParams *dynamic_params = base_dualencoder->codec_dynamic_params;
+  GstTIDmaiVideoInfo *video_info = (GstTIDmaiVideoInfo *) encoder_instance->media_info;
+
+  GST_DEBUG_OBJECT (base_dualencoder, "Configuring codec with %dx%d at %d/%d fps",
+      video_info->width,
+      video_info->height,
+      video_info->framerateN,
+      video_info->framerateD);
+
+  /* Set static params */
+  params->maxWidth = video_info->width;
+  params->maxHeight = video_info->height;
+
+  /* Set dynamic params */
+  dynamic_params->inputHeight = params->maxHeight;
+  dynamic_params->inputWidth = params->maxWidth;
+  /* Right now we use the stride from first plane, given that VIDENC1 assumes 
+   * that all planes have the same stride
+   */
+  dynamic_params->captureWidth =
+      video_info->pitch;
+
+  params->maxFrameRate =
+	video_info->framerateN * 1000;
+
+  dynamic_params->refFrameRate = params->maxFrameRate;
+  dynamic_params->targetFrameRate = params->maxFrameRate;
+
+  params->inputChromaFormat =
+      gst_tidmai_video_utils_dmai_video_info_to_xdm_chroma_format
+      (video_info->colorSpace);
+  params->reconChromaFormat = params->inputChromaFormat;
+  params->inputContentType =
+      gst_tidmai_video_utils_dmai_video_info_to_xdm_content_type
+      (video_info->colorSpace);
+
+  GST_DEBUG ("Leave initialize_params tidmaividenc1");
+  return TRUE;
+}
+
+/* Delete the actual codec instance */
+gboolean
+gst_tidmai_videnc1_delete (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance)
+{
+  GST_DEBUG_OBJECT (base_dualencoder, "ENTER");
+
+  if (encoder_instance != NULL) {
+    VIDENC1_delete (encoder_instance->codec_handle);
+  }
+  encoder_instance->codec_handle = NULL;
+
+  GST_DEBUG_OBJECT (base_dualencoder, "LEAVE");
+  return TRUE;
+}
+
+/* Create the codec instance and supply the dynamic params */
+gboolean
+gst_tidmai_videnc1_create (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance)
+{
+  
+  GST_DEBUG ("Enter _create tidmaividenc1");
+  gboolean ret;
+  VIDENC1_Status encStatus;
+
+  /* Check for the entry values */
+  if (base_dualencoder->engine_handle == NULL) {
+    GST_WARNING_OBJECT (base_dualencoder, "Engine handle is null");
+  }
+  if (base_dualencoder->codec_params == NULL) {
+    GST_WARNING_OBJECT (base_dualencoder, "Params are null");
+  }
+
+  if (base_dualencoder->codec_name == NULL) {
+    GST_WARNING_OBJECT (base_dualencoder, "Codec name is null");
+  }
+
+  /* Create the codec handle */
+  encoder_instance->codec_handle = VIDENC1_create (base_dualencoder->engine_handle,
+      (Char *) base_dualencoder->codec_name,
+      (VIDENC1_Params *) base_dualencoder->codec_params);
+
+  if (encoder_instance->codec_handle == NULL) {
+
+    GST_WARNING_OBJECT (base_dualencoder,
+        "Failed to create the instance of the codec %s with the given parameters",
+        base_dualencoder->codec_name);
+    return FALSE;
+  }
+
+  /* Supply the dynamic params */
+  ret = gst_tidmai_videnc1_control (base_dualencoder, encoder_instance, XDM_SETPARAMS, &encStatus);
+	
+  GST_DEBUG ("Leave _create tidmaividenc1");
+  return ret;
+}
+
+
+/* Implementation of process_sync for encode the buffer in a synchronous way */
+GList *
+gst_tidmai_videnc1_process_sync (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GList *input_buffers, GList *output_buffers, GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  IVIDEO1_BufDescIn inBufDesc;
+  XDM_BufDesc outBufDesc;
+  VIDENC1_InArgs inArgs;
+  VIDENC1_OutArgs outArgs;
+
+  XDAS_Int32 outBufSizeArray[XDM_MAX_IO_BUFFERS];
+  XDAS_Int8  *outBufPointers[XDM_MAX_IO_BUFFERS];
+
+  int status;
+  GList *current_list_buffer;
+  GstBuffer *current_buffer;
+  gint input_num_buffers = 0;
+  gint output_num_buffers = 0;
+  GstTIDmaiVideoInfo *video_info = (GstTIDmaiVideoInfo *)encoder_instance->media_info;	 
+ 
+  /****************************************************************/	
+  /** Prepare the input buffer descriptor for the encode process **/
+  /****************************************************************/
+  inBufDesc.frameWidth = video_info->width;
+  inBufDesc.frameHeight = video_info->height;
+  inBufDesc.framePitch = video_info->pitch;
+  
+  /* Each buffer is add to the descriptor */
+  current_list_buffer = input_buffers;
+  while(current_list_buffer) {
+	current_buffer = (GstBuffer *)current_list_buffer->data;
+	
+	inBufDesc.bufDesc[input_num_buffers].bufSize = GST_BUFFER_SIZE(current_buffer);
+	inBufDesc.bufDesc[input_num_buffers].buf = (XDAS_Int8 * ) GST_BUFFER_DATA(current_buffer);
+	
+	input_num_buffers = input_num_buffers + 1;
+	current_list_buffer = g_list_next (current_list_buffer); 
+  }
+  inBufDesc.numBufs = input_num_buffers;
+  
+  /*****************************************************************/
+  /** Prepare the output buffer descriptor for the encode process **/
+  /*****************************************************************/
+  /* Set the values to NULL */
+  memset(outBufPointers, 0, sizeof(outBufPointers[0]) * XDM_MAX_IO_BUFFERS);
+  memset(outBufSizeArray, 0,
+	sizeof(outBufSizeArray[0]) * XDM_MAX_IO_BUFFERS);
+
+  
+  current_list_buffer = output_buffers;
+  while(current_list_buffer) {
+	current_buffer = (GstBuffer *) current_list_buffer->data;
+
+	/* Set the values */
+	outBufPointers[output_num_buffers] = (XDAS_Int8 *)  GST_BUFFER_DATA(current_buffer);
+	outBufSizeArray[output_num_buffers] = GST_BUFFER_SIZE(current_buffer);
+	
+	output_num_buffers = output_num_buffers + 1;  
+	current_list_buffer = g_list_next (current_list_buffer); 
+  }
+  outBufDesc.numBufs = output_num_buffers;
+  outBufDesc.bufs = outBufPointers;
+  outBufDesc.bufSizes = outBufSizeArray;
+  
+  
+  /* Set output and input arguments for the encode process */
+  inArgs.size = sizeof (VIDENC1_InArgs); /* TODO: Maybe can change */
+  inArgs.inputID = 1;
+  inArgs.topFieldFirstFlag = 1;
+
+  outArgs.size = sizeof (VIDENC1_OutArgs); /* TODO: Maybe can change */
+
+  /* Procees la encode and check for errors */
+  status =
+      VIDENC1_process (encoder_instance->codec_handle, &inBufDesc, &outBufDesc,
+      &inArgs, &outArgs);
+
+  
+  if (status != VIDENC1_EOK) {
+    GST_ERROR_OBJECT (base_dualencoder,
+        "Incorrect sync encode process with extended error: 0x%x",
+        (unsigned int) outArgs.extendedError);
+    return NULL;
+  }
+
+  base_dualencoder->memoryUsed = outArgs.bytesGenerated;
+
+
+  return output_buffers;
+}
+
+/* Implementation of alloc_params that alloc memory for static and dynamic params 
+ * and set the default values of some params */
+void
+gst_tidmai_videnc1_alloc_params (GstTIDmaiBaseDualEncoder * base_dualencoder)
+{
+  GST_DEBUG_OBJECT (base_dualencoder, "ENTER");
+  VIDENC1_Params *params;
+  VIDENC1_DynamicParams *dynamic_params;
+
+  /* Allocate the static params */
+  base_dualencoder->codec_params = g_malloc0 (sizeof (VIDENC1_Params));
+  if (base_dualencoder->codec_params == NULL) {
+    GST_WARNING_OBJECT (base_dualencoder, "Failed to allocate VIDENC1_Params");
+    return;
+  }
+  params = base_dualencoder->codec_params;
+  /* Set default values for static params */
+  params->size = sizeof (VIDENC1_Params);
+  params->encodingPreset = XDM_HIGH_SPEED;
+  params->rateControlPreset = IVIDEO_LOW_DELAY;
+  params->maxBitRate = 6000000;
+  params->dataEndianness = XDM_BYTE;
+  params->maxInterFrameInterval = 1;
+
+  /* Allocate the dynamic params */
+  base_dualencoder->codec_dynamic_params =
+      g_malloc0 (sizeof (VIDENC1_DynamicParams));
+  if (base_dualencoder->codec_dynamic_params == NULL) {
+    GST_WARNING_OBJECT (base_dualencoder,
+        "Failed to allocate VIDENC1_DynamicParams");
+    return;
+  }
+  /* Set default values for dynamic params */
+  dynamic_params = base_dualencoder->codec_dynamic_params;
+  dynamic_params->size = sizeof (VIDENC1_DynamicParams);
+  dynamic_params->targetBitRate = 6000000;
+  dynamic_params->intraFrameInterval = 30;
+  dynamic_params->generateHeader = XDM_ENCODE_AU;
+  dynamic_params->forceFrame = IVIDEO_NA_FRAME;
+  dynamic_params->interFrameInterval = 1;
+
+  GST_DEBUG_OBJECT (base_dualencoder, "LEAVE");
+}
+
+static void
+gst_tidmai_videnc1_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  VIDENC1_Params *params = GST_TI_DMAI_BASE_DUALENCODER (object)->codec_params;
+  VIDENC1_DynamicParams *dynamic_params =
+      GST_TI_DMAI_BASE_DUALENCODER (object)->codec_dynamic_params;
+  switch (prop_id) {
+    case PROP_RATECONTROL:
+      params->rateControlPreset = g_value_get_int (value);
+      break;
+    case PROP_ENCODINGPRESET:
+      params->encodingPreset = g_value_get_int (value);
+      break;
+    case PROP_MAXBITRATE:
+      params->maxBitRate = g_value_get_int (value);
+      break;
+    case PROP_TARGETBITRATE:
+      dynamic_params->targetBitRate = g_value_get_int (value);
+      break;
+    case PROP_INTRAFRAMEINTERVAL:
+      dynamic_params->intraFrameInterval = g_value_get_int (value);
+      break;
+    default:
+      break;
+  }
+
+}
+
+static void
+gst_tidmai_videnc1_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+
+  VIDENC1_Params *params = GST_TI_DMAI_BASE_DUALENCODER (object)->codec_params;
+  VIDENC1_DynamicParams *dynamic_params =
+      GST_TI_DMAI_BASE_DUALENCODER (object)->codec_dynamic_params;
+  switch (prop_id) {
+    case PROP_RATECONTROL:
+      g_value_set_int (value, params->rateControlPreset);
+      break;
+    case PROP_ENCODINGPRESET:
+      g_value_set_int (value, params->encodingPreset);
+      break;
+    case PROP_MAXBITRATE:
+      g_value_set_int (value, params->maxBitRate);
+      break;
+    case PROP_TARGETBITRATE:
+      g_value_set_int (value, dynamic_params->targetBitRate);
+      break;
+    case PROP_INTRAFRAMEINTERVAL:
+      g_value_set_int (value, dynamic_params->intraFrameInterval);
+      break;
+    default:
+      break;
+  }
+}
+
+
+/* Install properties own from video dualencoders  */
+void
+gst_tidmai_videnc1_install_properties (GObjectClass * gobject_class)
+{
+	
+ g_object_class_install_property (gobject_class, PROP_RATECONTROL,
+      g_param_spec_int ("ratecontrol",
+          "Rate Control Algorithm",
+          "Rate Control Algorithm to use:\n"
+          "\t\t\t 1 - Constant Bit Rate (CBR), for video conferencing\n"
+          "\t\t\t 2 - Variable Bit Rate (VBR), for storage\n"
+          "\t\t\t 3 - Two pass rate control for non real time applications\n"
+          "\t\t\t 4 - No Rate Control is used\n"
+          "\t\t\t 5 - User defined on extended parameters",
+          1, 5, 1, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_ENCODINGPRESET,
+      g_param_spec_int ("encodingpreset",
+          "Encoding Preset Algorithm",
+          "Encoding Preset Algorithm to use:\n"
+          "\t\t\t 0 - Default (check codec documentation)\n"
+          "\t\t\t 1 - High Quality\n"
+          "\t\t\t 2 - High Speed\n"
+          "\t\t\t 3 - User defined on extended parameters",
+          0, 3, 2, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_MAXBITRATE,
+      g_param_spec_int ("maxbitrate",
+          "Maximum bit rate",
+          "Maximum bit-rate to be supported in bits per second",
+          1000, 20000000, 6000000, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_TARGETBITRATE,
+      g_param_spec_int ("targetbitrate",
+          "Target bit rate",
+          "Target bit-rate in bits per second, should be <= than the maxbitrate",
+          1000, 20000000, 6000000, G_PARAM_READWRITE));
+
+  g_object_class_install_property (gobject_class, PROP_INTRAFRAMEINTERVAL,
+      g_param_spec_int ("intraframeinterval",
+          "Intra frame interval",
+          "Interval between two consecutive intra frames:\n"
+          "\t\t\t 0 - Only first I frame followed by all P frames\n"
+          "\t\t\t 1 - No inter frames (all intra frames)\n"
+          "\t\t\t 2 - Consecutive IP sequence (if no B frames)\n"
+          "\t\t\t N - (n-1) P sequences between I frames\n",
+          0, G_MAXINT32, 30, G_PARAM_READWRITE));
+}
+
+
+/* Function that generate the pps and the sps of the codec 
+ * with the specific params
+ * */
+GstBuffer *
+gst_tidmai_videnc1_generate_header (GstTIDmaiVIDENC1 * videnc1_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance)
+{
+
+  GstBuffer *header;
+  GstBuffer *input_buffer;
+  GstBuffer *output_buffer;
+  GList *input_buffers = NULL;
+  GList *output_buffers = NULL;
+  GList *header_buffers = NULL;
+  VIDENC1_Status encStatus;
+
+  /* Set the params */
+  VIDENC1_DynamicParams *dynamic_params =
+      GST_TI_DMAI_BASE_DUALENCODER (videnc1_dualencoder)->codec_dynamic_params;
+  dynamic_params->generateHeader = XDM_GENERATE_HEADER;
+  if (!gst_tidmai_videnc1_control (GST_TI_DMAI_BASE_DUALENCODER(videnc1_dualencoder), encoder_instance, XDM_SETPARAMS, &encStatus)) {
+    GST_WARNING_OBJECT (videnc1_dualencoder,
+        "Probles for set params for generate header");
+    return NULL;
+  }
+
+  /* Prepare the input and output buffers */
+  input_buffer = gst_buffer_new_and_alloc (100);        /* TODO: Dummy buffers */
+  output_buffer = gst_buffer_new_and_alloc (100);       /* TODO: Dummy buffers */
+  input_buffers = g_list_append(input_buffers, input_buffer);
+  output_buffers = g_list_append(output_buffers, output_buffer);
+  
+  /* Generate the header */
+  header_buffers =
+      gst_tidmai_videnc1_process_sync (GST_TI_DMAI_BASE_DUALENCODER(videnc1_dualencoder), input_buffers,
+      output_buffers, encoder_instance);
+  
+  //gst_buffer_unref (input_buffer);
+	
+  header = header_buffers->data;	
+
+  /* Reset to the params to the origina value */
+  dynamic_params->generateHeader = XDM_ENCODE_AU;
+  dynamic_params->forceFrame = XDM_ENCODE_AU;
+  gst_tidmai_videnc1_control (GST_TI_DMAI_BASE_DUALENCODER(videnc1_dualencoder), encoder_instance, XDM_SETPARAMS, &encStatus);
+
+  if (header == NULL) {
+    GST_WARNING_OBJECT (videnc1_dualencoder,
+        "Probles for generate header with the actual params");
+    return NULL;
+  }
+
+  return header;
+}
+
+
+static void
+gst_tidmai_videnc1_class_init (GstTIDmaiVIDENC1Class * klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *) klass;
+
+  /* Obtain base class */
+  GstTIDmaiBaseDualEncoderClass *base_dualencoder_class = GST_TI_DMAI_BASE_DUALENCODER_CLASS (klass);
+
+  GST_DEBUG_CATEGORY_INIT (gst_tidmai_videnc1_debug, "tidmaividenc1", 0,
+      "Codec Engine VIDENC1 Class");
+
+  GST_DEBUG ("ENTER");
+
+  /* Implement of heredity functions */
+  base_dualencoder_class->base_dualencoder_control = gst_tidmai_videnc1_control;
+  base_dualencoder_class->base_dualencoder_delete = gst_tidmai_videnc1_delete;
+  base_dualencoder_class->base_dualencoder_create = gst_tidmai_videnc1_create;
+  base_dualencoder_class->base_dualencoder_process_sync = gst_tidmai_videnc1_process_sync;
+  base_dualencoder_class->base_dualencoder_initialize_params =
+      gst_tidmai_videnc1_initialize_params;
+  base_dualencoder_class->base_dualencoder_alloc_params =  
+      gst_tidmai_videnc1_alloc_params;
+  gobject_class->set_property = gst_tidmai_videnc1_set_property;
+  gobject_class->get_property = gst_tidmai_videnc1_get_property;
+
+  /* Install properties for the class */
+  gst_tidmai_videnc1_install_properties (gobject_class);
+
+  GST_DEBUG ("LEAVE");
+}
+
+/* init of the class */
+static void
+gst_tidmai_videnc1_init (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GstTIDmaiBaseDualEncoderClass * base_dualencoder_class)
+{
+  GST_DEBUG ("Enter init videnc1");
+  
+  /* Allocate the static and dinamic params */
+  gst_tidmai_base_dualencoder_alloc_params(base_dualencoder);
+  
+  GST_DEBUG ("Leave init videnc1");
+}
+
+/* Obtain and register the type of the class */
+GType
+gst_tidmai_videnc1_get_type (void)
+{
+  static GType object_type = 0;
+
+  if (object_type == 0) {
+    static const GTypeInfo object_info = {
+      sizeof (GstTIDmaiVIDENC1Class),
+      (GBaseInitFunc) gst_tidmai_videnc1_base_init,
+      (GBaseFinalizeFunc) gst_tidmai_videnc1_base_finalize,
+      (GClassInitFunc) gst_tidmai_videnc1_class_init,
+      NULL,
+      NULL,
+      sizeof (GstTIDmaiVIDENC1),
+      0,
+      (GInstanceInitFunc) gst_tidmai_videnc1_init
+    };
+
+    object_type = g_type_register_static (GST_TYPE_TI_DMAI_BASE_VIDEO_DUALENCODER,
+        "GstTIDmaiVIDENC1", &object_info, (GTypeFlags) 0);
+  }
+  return object_type;
+};
Index: gst-dmai-plugins/src/src/gsttidmaividenc1.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaividenc1.h	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,96 @@
+/*
+ * Authors:
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifndef ___GST_TI_DMAI_VIDENC1_H__
+#define ___GST_TI_DMAI_VIDENC1_H__
+
+#include <gst/gst.h>
+#include "gsttidmaibasevideodualencoder.h"
+
+#include <xdc/std.h>
+#include <ti/sdo/ce/Engine.h>
+#include <ti/sdo/ce/video1/videnc1.h>
+
+G_BEGIN_DECLS
+#define GST_TYPE_TI_DMAI_VIDENC1 \
+  (gst_tidmai_videnc1_get_type())
+#define GST_TI_DMAI_VIDENC1(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TI_DMAI_VIDENC1,GstTIDmaiVIDENC1))
+#define GST_TI_DMAI_VIDENC1_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TI_DMAI_VIDENC1,GstTIDmaiVIDENC1Class))
+#define GST_IS_TI_DMAI_VIDENC1(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TI_DMAI_VIDENC1))
+#define GST_IS_TI_DMAI_VIDENC1_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TI_DMAI_VIDENC1))
+#define GST_TIDMAI_VIDENC1_GET_CLASS(obj) \
+(G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TI_DMAI_VIDENC1, GstTIDmaiVIDENC1Class))
+typedef struct _GstTIDmaiVIDENC1 GstTIDmaiVIDENC1;
+typedef struct _GstTIDmaiVIDENC1Class GstTIDmaiVIDENC1Class;
+
+/**
+ * This class implements CodecEngine VIDENC1 API
+ * @extends _GstTIDmaiBaseVideoDualEncoder
+ */
+struct _GstTIDmaiVIDENC1
+{
+  GstTIDmaiBaseVideoDualEncoder base_video_dualencoder;
+};
+
+struct _GstTIDmaiVIDENC1Class
+{
+  GstTIDmaiBaseVideoDualEncoderClass parent_class;
+
+};
+/* Macros that allow access to the method of the class */
+
+/*-------------------*/
+/* Public methods */
+/*-------------------*/
+
+GstBuffer *
+  gst_tidmai_videnc1_generate_header (GstTIDmaiVIDENC1 * videnc1_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance);
+
+gboolean
+  gst_tidmai_videnc1_initialize_params (GstTIDmaiBaseDualEncoder * base_dualencoder, GstTIDmaiDualEncInstance *encoder_instance);
+
+gboolean
+  gst_tidmai_videnc1_control (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance, gint cmd_id, VIDENC1_Status *encStatus);
+
+gboolean
+  gst_tidmai_videnc1_delete (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance);
+
+gboolean
+  gst_tidmai_videnc1_create (GstTIDmaiBaseDualEncoder * base_dualencoder, 
+	GstTIDmaiDualEncInstance *encoder_instance);
+
+/* Return a list of output buffers */
+GList*
+  gst_tidmai_videnc1_process_sync (GstTIDmaiBaseDualEncoder * base_dualencoder,
+    GList *input_buffers, GList *output_buffers, GstTIDmaiDualEncInstance *encoder_instance);
+
+void
+  gst_tidmai_videnc1_alloc_params (GstTIDmaiBaseDualEncoder * base_dualencoder);
+
+
+/* Class functionality */
+GType gst_tidmai_videnc1_get_type (void);
+
+G_END_DECLS
+#endif /* ___GST_TI_DMAI_VIDENC1_H__ */
Index: gst-dmai-plugins/src/src/gsttidmaivideoutils.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaivideoutils.c	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,46 @@
+/*
+ * Authors:
+ *   Diego Dompe <ddompe@gmail.com>
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#include "gsttidmaivideoutils.h"
+
+/* Set the chroma format param for the codec instance depends of the video mime type (format) */
+XDAS_Int32
+gst_tidmai_video_utils_dmai_video_info_to_xdm_chroma_format (ColorSpace_Type format)
+{
+  switch (format) {
+    case ColorSpace_YUV420PSEMI:
+      return XDM_YUV_420SP; /* For dm368, this is the only content type that support for now */
+    default:
+      GST_ERROR ("Failed to convert ColorSpace at function %s", __FUNCTION__);
+      return XDM_CHROMA_NA;
+  }
+}
+
+/* Set the content type param for the codec instance depends of the video mime type (format) */
+XDAS_Int32
+gst_tidmai_video_utils_dmai_video_info_to_xdm_content_type (ColorSpace_Type format)
+{
+  switch (format) {
+    case ColorSpace_YUV420PSEMI:
+      return IVIDEO_PROGRESSIVE;        /* For dm368, this is the only content type that support for now */
+    default:
+      GST_ERROR ("Failed to figure out video content type at function %s",
+          __FUNCTION__);
+      return IVIDEO_CONTENTTYPE_DEFAULT;
+  }
+}
Index: gst-dmai-plugins/src/src/gsttidmaivideoutils.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gst-dmai-plugins/src/src/gsttidmaivideoutils.h	2012-09-03 17:38:26.893164797 -0600
@@ -0,0 +1,36 @@
+/*
+ * Authors:
+ *   Diego Dompe <ddompe@gmail.com>
+ *   Luis Arce <luis.arce@rigerun.com>
+ *
+ * Copyright (C) 2012 RidgeRun	
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation version 2.1 of the License.
+ *
+ * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ */
+
+#ifndef ___GST_CE_VIDEO_UTILS_H__
+#define ___GST_CE_VIDEO_UTILS_H__
+
+#include <gst/gst.h>
+#include <xdc/std.h>
+#include <ti/xdais/xdas.h>
+#include <ti/sdo/ce/Engine.h>
+#include <ti/sdo/ce/video1/videnc1.h>
+#include <ti/sdo/dmai/ColorSpace.h>
+
+
+XDAS_Int32
+gst_tidmai_video_utils_dmai_video_info_to_xdm_chroma_format (ColorSpace_Type format);
+
+XDAS_Int32
+gst_tidmai_video_utils_dmai_video_info_to_xdm_content_type (ColorSpace_Type format);
+
+#endif /* ___GST_CE_VIDEO_UTILS_H__ */
Index: gst-dmai-plugins/src/src/gsttidmaibuffertransport.c
===================================================================
--- gst-dmai-plugins.orig/src/src/gsttidmaibuffertransport.c	2012-09-03 17:38:23.825164781 -0600
+++ gst-dmai-plugins/src/src/gsttidmaibuffertransport.c	2012-09-03 17:38:26.893164797 -0600
@@ -145,37 +145,42 @@
     /* If the DMAI buffer is part of a BufTab, free it for re-use.  Otherwise,
      * destroy the buffer.
      */
-    if (Buffer_getBufTab(cbuf->dmaiBuffer) != NULL) {
-        /* Hold mutex, if available */
-        if (cbuf->mutex)
-            pthread_mutex_lock(cbuf->mutex);
+	
+	if(cbuf->dmaiBuffer != NULL) 
+	{
+		if (Buffer_getBufTab(cbuf->dmaiBuffer) != NULL) {
+			/* Hold mutex, if available */
+			if (cbuf->mutex)
+				pthread_mutex_lock(cbuf->mutex);
 
-        Buffer_freeUseMask(cbuf->dmaiBuffer,
-            gst_tidmaibuffertransport_GST_FREE);
+			Buffer_freeUseMask(cbuf->dmaiBuffer,
+				gst_tidmaibuffertransport_GST_FREE);
 
-        GST_DEBUG("clearing useMask bit so buffer %p can be reused: new mask %dh\n",
-            cbuf->dmaiBuffer,Buffer_getUseMask(cbuf->dmaiBuffer));
-        /* If pthread conditional is set then wake-up caller */
-        if (cbuf->cond) {
-            if (Buffer_getUseMask(cbuf->dmaiBuffer) == 0) {
-                pthread_cond_broadcast(cbuf->cond);
-            } else {
-                GST_DEBUG("Not broadcasting buffer free at finalize, since use mask is not clean yet");
-            }
-        }
-        /* Release mutex, if available */
-        if (cbuf->mutex)
-           pthread_mutex_unlock(cbuf->mutex);
-    } else {
-        GST_LOG("calling Buffer_delete()\n");
-        Buffer_delete(cbuf->dmaiBuffer);
-    }
+			GST_DEBUG("clearing useMask bit so buffer %p can be reused: new mask %dh\n",
+				cbuf->dmaiBuffer,Buffer_getUseMask(cbuf->dmaiBuffer));
+			/* If pthread conditional is set then wake-up caller */
+			if (cbuf->cond) {
+				if (Buffer_getUseMask(cbuf->dmaiBuffer) == 0) {
+					pthread_cond_broadcast(cbuf->cond);
+				} else {
+					GST_DEBUG("Not broadcasting buffer free at finalize, since use mask is not clean yet");
+				}
+			}
+			/* Release mutex, if available */
+			if (cbuf->mutex)
+			   pthread_mutex_unlock(cbuf->mutex);
+		} else {
+			GST_LOG("calling Buffer_delete()\n");
+			Buffer_delete(cbuf->dmaiBuffer);
+		}
+	}
     
     gst_caps_replace (&GST_BUFFER_CAPS (GST_BUFFER(cbuf)), NULL);
-
+    
+	/* finalize the parent class */
     GST_MINI_OBJECT_CLASS (parent_class)->finalize                                                             
         (GST_MINI_OBJECT_CAST (cbuf)); 
-    
+    	
     GST_LOG("end finalize\n");
 }
 
Index: gst-dmai-plugins/src/src/Makefile.am
===================================================================
--- gst-dmai-plugins.orig/src/src/Makefile.am	2012-09-03 17:38:23.845164780 -0600
+++ gst-dmai-plugins/src/src/Makefile.am	2012-09-03 17:38:26.893164797 -0600
@@ -9,8 +9,11 @@
 gsttisupport_mpeg2.c \
 gsttiauddec1.c gsttiauddec.c gsttiaudenc1.c gsttiaudenc.c gsttiimgenc1.c gsttiimgenc.c \
 gsttiimgdec.c gsttiimgdec1.c \
-gsttisupport_aac.c gsttisupport_mp3.c gsttisupport_wma.c gsttidmaiperf.c\
-gstticommonutils.c ti_encoders.c ti_decoders.c ittiam_encoders.c ittiam_caps.c caps.c
+gsttisupport_aac.c gsttisupport_mp3.c gsttisupport_wma.c gsttidmaiperf.c \
+gstticommonutils.c ti_encoders.c ti_decoders.c ittiam_encoders.c ittiam_caps.c caps.c \
+gsttidmaibasedualencoder.c gsttidmaibasevideodualencoder.c \
+gsttidmaih264dualencoder.c gsttidmaividenc1.c \
+gsttidmaivideoutils.c
 
 # flags used to compile this plugin
 # add other _CFLAGS and _LIBS as needed
@@ -28,7 +31,10 @@
 gsttiparsers.h gsttisupport_generic.h gsttisupport_h264.h gsttisupport_mpeg2.h \
 gsttisupport_mpeg4.h gsttisupport_aac.h gsttisupport_mp3.h \
 gsttisupport_wma.h gsttisupport_jpeg.h ti_encoders.h ti_decoders.h caps.h gsttidmaidec.h \
-gsttidmaienc.h gsttidmaiaccel.h gsttipriority.h ittiam_encoders.h ittiam_caps.h
+gsttidmaienc.h gsttidmaiaccel.h gsttipriority.h ittiam_encoders.h ittiam_caps.h \
+gsttidmaibasedualencoder.h gsttidmaibasevideodualencoder.h \
+gsttidmaih264dualencoder.h gsttidmaividenc1.h \
+gsttidmaivideoutils.h
 
 # XDC Configuration
 CONFIGURO     = $(XDC_INSTALL_DIR)/xs xdc.tools.configuro
Index: gst-dmai-plugins/src/src/gstticodecplugin.c
===================================================================
--- gst-dmai-plugins.orig/src/src/gstticodecplugin.c	2012-09-03 17:38:23.809164781 -0600
+++ gst-dmai-plugins/src/src/gstticodecplugin.c	2012-09-03 17:38:26.893164797 -0600
@@ -58,6 +58,7 @@
 #include "ti_encoders.h"
 #include "ti_decoders.h"
 #include "ittiam_encoders.h"
+#include "gsttidmaih264dualencoder.h"
 
 
 extern struct gstti_decoder_ops gstti_viddec_ops;
@@ -477,7 +478,13 @@
     if (!gst_element_register(TICodecPlugin, "dmairesizer",
         GST_RANK_PRIMARY,GST_TYPE_DMAI_RESIZER))
         return FALSE;
-
+    
+	if (!gst_element_register(TICodecPlugin, "dmaidualenc_h264",
+        GST_RANK_PRIMARY,GST_TYPE_TI_DMAI_H264_DUALENCODER)) {
+		return FALSE;
+	}
+	
+	
     return TRUE;
 }
 

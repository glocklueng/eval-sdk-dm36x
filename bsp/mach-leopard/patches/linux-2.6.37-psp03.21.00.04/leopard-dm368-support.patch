Index: kernel/linux-2.6.37-psp03.21.00.04/arch/arm/tools/mach-types
===================================================================
--- kernel.orig/linux-2.6.37-psp03.21.00.04/arch/arm/tools/mach-types	2014-11-11 08:57:52.000000000 -0700
+++ kernel/linux-2.6.37-psp03.21.00.04/arch/arm/tools/mach-types	2015-05-11 11:32:06.717317935 -0600
@@ -3219,3 +3219,4 @@
 pcm048			MACH_PCM048		PCM048			3236
 dds			MACH_DDS		DDS			3237
 chalten_xa1		MACH_CHALTEN_XA1	CHALTEN_XA1		3238
+dm368_leopard           MACH_DM368_LEOPARD      DM368_LEOPARD           3449
Index: kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Kconfig	2014-11-11 08:57:51.000000000 -0700
+++ kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Kconfig	2015-05-11 11:32:06.717317935 -0600
@@ -122,6 +122,13 @@
 	  Configure this option to specify whether the board used
 	  for development is a DM365 EVM
 
+config MACH_DM368_LEOPARD
+       bool "DM368 Leopard board"
+       depends on ARCH_DAVINCI_DM365
+       help
+         Configure this option to specify the whether the board used
+         for development is a DM368 Leopard board.
+
 config MACH_DAVINCI_DA830_EVM
 	bool "TI DA830/OMAP-L137/AM17x Reference Platform"
 	default ARCH_DAVINCI_DA830
Index: kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Makefile	2014-11-11 08:57:51.000000000 -0700
+++ kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/Makefile	2015-05-11 11:32:06.717317935 -0600
@@ -30,6 +30,7 @@
 obj-$(CONFIG_MACH_DM355_LEOPARD)	+= board-dm355-leopard.o
 obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)	+= board-dm646x-evm.o cdce949.o
 obj-$(CONFIG_MACH_DAVINCI_DM365_EVM)	+= board-dm365-evm.o
+obj-$(CONFIG_MACH_DM368_LEOPARD)       += board-dm368-leopard.o
 obj-$(CONFIG_MACH_DAVINCI_DA830_EVM)	+= board-da830-evm.o
 obj-$(CONFIG_MACH_DAVINCI_DA850_EVM)	+= board-da850-evm.o
 obj-$(CONFIG_MACH_TNETV107X)		+= board-tnetv107x-evm.o
Index: kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/board-dm368-leopard.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp03.21.00.04/arch/arm/mach-davinci/board-dm368-leopard.c	2015-05-11 12:14:55.918856139 -0600
@@ -0,0 +1,493 @@
+/*
+ * DM368 Leopard Board
+ *
+ * Derived from: arch/arm/mach-davinci/board-dm365-evm.c
+ * RidgeRun Copyright (C) 2011.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <generated/autoconf.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/i2c/at24.h>
+#include <linux/leds.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/input.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/mux.h>
+#include <mach/hardware.h>
+#include <mach/dm365.h>
+#include <mach/psc.h>
+#include <mach/common.h>
+#include <mach/i2c.h>
+#include <mach/serial.h>
+#include <mach/mmc.h>
+#include <mach/nand.h>
+#include <mach/keyscan.h>
+#include <mach/gpio.h>
+#include <linux/videodev2.h>
+#ifdef CONFIG_BSP_VIDEO_OUTPUT_PRGB
+#include <media/davinci/videohd.h>
+#include <media/davinci/dm365_generic_prgb_encoder.h>
+#endif
+#include <media/tvp514x.h>
+#include <media/tvp7002.h>
+
+#define DM365_EVM_PHY_MASK		(0x2)
+#define DM365_EVM_MDIO_FREQUENCY	(2200000) /* PHY bus frequency */
+
+#if defined(CONFIG_SND_DM365_AIC3X_CODEC) || defined(CONFIG_SND_DM365_VOICE_CODEC)
+static struct snd_platform_data dm368_leopard_snd_data = {
+	.asp_chan_q = EVENTQ_3,
+};
+#endif
+
+static struct i2c_board_info i2c_info[] = {
+	{
+		I2C_BOARD_INFO("tlv320aic3x", 0x18),
+	},
+	{
+		I2C_BOARD_INFO("ths7303", 0x2c),
+	}
+};
+
+static struct davinci_i2c_platform_data i2c_pdata = {
+	.bus_freq	= 400	/* kHz */,
+	.bus_delay	= 0	/* usec */,
+	.sda_pin        = 21,
+	.scl_pin        = 20,
+};
+
+#if defined(CONFIG_SOC_CAMERA_MT9P031) || defined(CONFIG_SOC_CAMERA_MT9P031_MODULE)
+/* Input available at the mt9p031 */
+static struct v4l2_input mt9p031_inputs[] = {
+	{
+		.index = 0,
+		.name = "Camera",
+		.type = V4L2_INPUT_TYPE_CAMERA,
+	}
+};
+#endif
+
+#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+static struct tvp514x_platform_data tvp5146_pdata = {
+       .clk_polarity = 0,
+       .hs_polarity = 1,
+       .vs_polarity = 1
+};
+
+
+#define TVP514X_STD_ALL        (V4L2_STD_NTSC | V4L2_STD_PAL)
+/* Inputs available at the TVP5146 */
+static struct v4l2_input tvp5146_inputs[] = {
+	{
+		.index = 0,
+		.name = "Composite",
+		.type = V4L2_INPUT_TYPE_CAMERA,
+		.std = TVP514X_STD_ALL,
+	},
+	{
+		.index = 1,
+		.name = "S-Video",
+		.type = V4L2_INPUT_TYPE_CAMERA,
+		.std = TVP514X_STD_ALL,
+	},
+};
+
+/*
+ * this is the route info for connecting each input to decoder
+ * ouput that goes to vpfe. There is a one to one correspondence
+ * with tvp5146_inputs
+ */
+static struct vpfe_route tvp5146_routes[] = {
+	{
+		.input = INPUT_CVBS_VI2B,
+		.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+	},
+	{
+		.input = INPUT_SVIDEO_VI2C_VI1C,
+		.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
+	},
+};
+#endif
+
+#if defined(CONFIG_VIDEO_TVP7002) || defined(CONFIG_VIDEO_TVP7002_MODULE)
+/* tvp7002 platform data, used during reset and probe operations */
+static struct tvp7002_platform_data tvp7002_pdata = {
+       .clk_polarity = 0,
+       .hs_polarity = 0,
+       .vs_polarity = 0,
+       .fid_polarity = 0,
+};
+
+
+#define TVP7002_STD_ALL        (V4L2_STD_525P_60   | V4L2_STD_625P_50 	|\
+				V4L2_STD_NTSC      | V4L2_STD_PAL   	|\
+				V4L2_STD_720P_50   | V4L2_STD_720P_60 	|\
+				V4L2_STD_1080I_50  | V4L2_STD_1080I_60 	|\
+				V4L2_STD_1080P_50  | V4L2_STD_1080P_60)
+
+/* Inputs available at the TVP7002 */
+static struct v4l2_input tvp7002_inputs[] = {
+	{
+		.index = 0,
+		.name = "Component",
+		.type = V4L2_INPUT_TYPE_CAMERA,
+		.std = TVP7002_STD_ALL,
+	},
+};
+#endif
+
+
+static struct vpfe_subdev_info vpfe_sub_devs[] = {
+#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+	{
+		.module_name = "tvp5146",
+		.grp_id = VPFE_SUBDEV_TVP5146,
+		.num_inputs = ARRAY_SIZE(tvp5146_inputs),
+		.inputs = tvp5146_inputs,
+		.routes = tvp5146_routes,
+		.can_route = 1,
+		.ccdc_if_params = {
+			.if_type = V4L2_MBUS_FMT_YUYV8_2X8,
+			.hdpol = VPFE_PINPOL_POSITIVE,
+			.vdpol = VPFE_PINPOL_POSITIVE,
+		},
+		.board_info = {
+			I2C_BOARD_INFO("tvp5146", 0x5d),
+			.platform_data = &tvp5146_pdata,
+		},
+	},
+#endif
+#if defined(CONFIG_VIDEO_TVP7002) || defined(CONFIG_VIDEO_TVP7002_MODULE)
+	{
+		.module_name = "tvp7002",
+		.grp_id = VPFE_SUBDEV_TVP7002,
+		.num_inputs = ARRAY_SIZE(tvp7002_inputs),
+		.inputs = tvp7002_inputs,
+		.ccdc_if_params = {
+			.if_type = VPFE_BT1120,
+			.hdpol = VPFE_PINPOL_POSITIVE,
+			.vdpol = VPFE_PINPOL_POSITIVE,
+		},
+		.board_info = {
+			I2C_BOARD_INFO("tvp7002", 0x5c),
+			.platform_data = &tvp7002_pdata,
+		},
+	},
+	{
+		.module_name = "ths7353",
+		.grp_id = VPFE_SUBDEV_TVP7002,
+		.board_info = {
+			I2C_BOARD_INFO("ths7353", 0x2e),
+		},
+	},
+#endif
+#if defined(CONFIG_SOC_CAMERA_MT9P031) || defined(CONFIG_SOC_CAMERA_MT9P031_MODULE)
+	{
+		.module_name = "mt9p031",
+		.is_camera = 1,
+		.grp_id = VPFE_SUBDEV_MT9P031,
+		.num_inputs = ARRAY_SIZE(mt9p031_inputs),
+		.inputs = mt9p031_inputs,
+		.ccdc_if_params = {
+			.if_type = V4L2_MBUS_FMT_SBGGR10_1X10,
+			.hdpol = VPFE_PINPOL_POSITIVE,
+			.vdpol = VPFE_PINPOL_POSITIVE,
+		},
+		.board_info = {
+			I2C_BOARD_INFO("mt9p031", 0x48),
+			/* this is for PCLK rising edge */
+			.platform_data = (void *)1,
+		},
+	}
+#endif
+};
+
+static struct vpfe_config vpfe_cfg = {
+       .num_subdevs = ARRAY_SIZE(vpfe_sub_devs),
+       .sub_devs = vpfe_sub_devs,
+       .card_name = "DM368 Leopard",
+};
+
+static struct davinci_mmc_config dm368leopard_mmc_config = {
+	.wires		= 4,
+	.max_freq	= 50000000,
+	.caps		= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED,
+	.version	= MMC_CTLR_VERSION_2,
+};
+
+static void dm368leopard_emac_configure(void)
+{
+	/*
+	 * EMAC pins are multiplexed with GPIO and UART
+	 * Further details are available at the DM368 ARM
+	 * Subsystem Users Guide(sprufg5.pdf) pages 125 - 127
+	 */
+	davinci_cfg_reg(DM365_EMAC_TX_EN);
+	davinci_cfg_reg(DM365_EMAC_TX_CLK);
+	davinci_cfg_reg(DM365_EMAC_COL);
+	davinci_cfg_reg(DM365_EMAC_TXD3);
+	davinci_cfg_reg(DM365_EMAC_TXD2);
+	davinci_cfg_reg(DM365_EMAC_TXD1);
+	davinci_cfg_reg(DM365_EMAC_TXD0);
+	davinci_cfg_reg(DM365_EMAC_RXD3);
+	davinci_cfg_reg(DM365_EMAC_RXD2);
+	davinci_cfg_reg(DM365_EMAC_RXD1);
+	davinci_cfg_reg(DM365_EMAC_RXD0);
+	davinci_cfg_reg(DM365_EMAC_RX_CLK);
+	davinci_cfg_reg(DM365_EMAC_RX_DV);
+	davinci_cfg_reg(DM365_EMAC_RX_ER);
+	davinci_cfg_reg(DM365_EMAC_CRS);
+	davinci_cfg_reg(DM365_EMAC_MDIO);
+	davinci_cfg_reg(DM365_EMAC_MDCLK);
+
+	/*
+	 * EMAC interrupts are multiplexed with GPIO interrupts
+	 * Details are available at the DM365 ARM
+	 * Subsystem Users Guide(sprufg5.pdf) pages 133 - 134
+	 */
+	davinci_cfg_reg(DM365_INT_EMAC_RXTHRESH);
+	davinci_cfg_reg(DM365_INT_EMAC_RXPULSE);
+	davinci_cfg_reg(DM365_INT_EMAC_TXPULSE);
+	davinci_cfg_reg(DM365_INT_EMAC_MISCPULSE);
+}
+
+static void dm368leopard_mmc_configure(void)
+{
+	/*
+	 * MMC/SD pins are multiplexed with GPIO and EMIF
+	 * Further details are available at the DM365 ARM
+	 * Subsystem Users Guide(sprufg5.pdf) pages 118, 128 - 131
+	 */
+	davinci_cfg_reg(DM365_SD1_CLK);
+	davinci_cfg_reg(DM365_SD1_CMD);
+	davinci_cfg_reg(DM365_SD1_DATA3);
+	davinci_cfg_reg(DM365_SD1_DATA2);
+	davinci_cfg_reg(DM365_SD1_DATA1);
+	davinci_cfg_reg(DM365_SD1_DATA0);
+}
+
+static void dm368leopard_usb_configure(void)
+{
+	davinci_cfg_reg(DM365_GPIO66);
+	gpio_request(66, "usb");
+	gpio_direction_output(66, 0);
+}
+
+#ifdef CONFIG_SND_DM365_AIC3X_CODEC
+static void dm368leopard_tlv320aic3x_configure(void)
+{
+	/*
+	* CLKOUT1 pin is multiplexed with GPIO35 and SPI4
+	* Further details are available at the DM365 ARM
+	* Subsystem Users Guide(sprufg5.pdf) pages 118, 127 - 129
+	*/
+	struct clk *clkout1_clk;
+
+	davinci_cfg_reg(DM365_CLKOUT1);
+
+	clkout1_clk = clk_get(NULL, "clkout1");
+	if (IS_ERR(clkout1_clk))
+		return;
+	clk_enable(clkout1_clk);
+
+	/*
+	* Configure CLKOUT1 OBSCLK registers
+	*/
+
+	/* (reg OCSEL) Setting OBSCLK source with Oscillator divider output enable */
+	__raw_writel(0x0,IO_ADDRESS(0x01C40C00 + 0x104));
+
+	/* (reg OSCDIV1) Setting the Oscillator divider enable with a divider ratio of 1 */
+	__raw_writel(0x8000,IO_ADDRESS(0x01C40C00 + 0x124));
+
+	/* (reg CKEN) Setting the OBSCLK clock enable */
+	__raw_writel(0x02,IO_ADDRESS(0x01C40C00 + 0x148));
+}
+#endif
+
+#ifdef CONFIG_BSP_VIDEO_OUTPUT_PRGB
+static void dm368leopard_prgb_out_configure(void)
+{
+	/*
+	 * R/G/B 0 and 1 pins are multiplexed with GPIOs
+	 * Further details are available at the DM365 ARM
+	 * Subsystem Users Guide(sprufg5.pdf) pages 118, 128 - 131
+	 */
+	davinci_cfg_reg(DM365_VOUT_B0);
+	davinci_cfg_reg(DM365_VOUT_B1);
+	davinci_cfg_reg(DM365_VOUT_B2);
+	davinci_cfg_reg(DM365_VOUT_R0);
+	davinci_cfg_reg(DM365_VOUT_R1);
+	davinci_cfg_reg(DM365_VOUT_R2);
+	davinci_cfg_reg(DM365_VOUT_G0);
+	davinci_cfg_reg(DM365_VOUT_G1);
+	davinci_cfg_reg(DM365_VOUT_COUTL_EN);
+	davinci_cfg_reg(DM365_VOUT_COUTH_EN);
+	davinci_cfg_reg(DM365_VOUT_LCD_OE);
+	davinci_cfg_reg(DM365_VOUT_HVSYNC);
+}
+#else
+#define dm368leopard_prgb_out_configure() do {} while(0)
+#endif
+
+void enable_lcd(void)
+{
+}
+EXPORT_SYMBOL(enable_lcd);
+
+void enable_hd_clk(void)
+{
+}
+EXPORT_SYMBOL(enable_hd_clk);
+
+
+static void __init leopard_init_i2c(void)
+{
+	davinci_cfg_reg(DM365_GPIO20);
+	gpio_request(20, "i2c-scl");
+	gpio_direction_output(20, 0);
+	davinci_cfg_reg(DM365_I2C_SCL);
+
+	davinci_init_i2c(&i2c_pdata);
+	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
+}
+
+#ifdef CONFIG_BSP_VIDEO_OUTPUT_PRGB
+int set_prgb_pixel_clk_output(unsigned int required_clk_rate);
+
+static struct davinci_gen_prgb_pdata gen_prgb_data = {
+	.xres = 1280,
+	.yres = 720,
+	.fps = {60, 1},
+	.pixel_clock_khz = 0,
+	.left_margin = 300,
+	.right_margin = 70,
+	.upper_margin = 26,
+	.lower_margin = 3,
+	.hsync_len = 80,
+	.vsync_len = 5,
+	.flags = 0,
+	.clock_set_function = NULL,
+};
+
+static struct platform_device gen_prgb_device = {
+	.name			= PRGB_ENCODER_DRV_NAME,
+	.id				= 0,
+	.num_resources	= 0,
+	.resource		= NULL,
+	.dev			= {
+		.platform_data	= &gen_prgb_data,
+	},
+};
+#endif
+
+static struct davinci_nand_pdata davinci_nand_data = {
+	.mask_chipsel		= 0,
+	.ecc_mode		= NAND_ECC_HW,
+	.options		= NAND_SKIP_BBTSCAN | NAND_NO_SUBPAGE_WRITE,
+	.ecc_bits		= 4,
+};
+
+static struct resource davinci_nand_resources[] = {
+	{
+		.start		= DM365_ASYNC_EMIF_DATA_CE0_BASE,
+		.end		= DM365_ASYNC_EMIF_DATA_CE0_BASE + SZ_32M - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= DM365_ASYNC_EMIF_CONTROL_BASE,
+		.end		= DM365_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device davinci_nand_device = {
+	.name			= "davinci_nand",
+	.id			= 0,
+	.num_resources		= ARRAY_SIZE(davinci_nand_resources),
+	.resource		= davinci_nand_resources,
+	.dev			= {
+		.platform_data	= &davinci_nand_data,
+	},
+};
+
+static struct platform_device *dm368_leopard_devices[] __initdata = {
+	&davinci_nand_device,
+#ifdef CONFIG_BSP_VIDEO_OUTPUT_PRGB
+	&gen_prgb_device,
+#endif
+};
+
+
+static struct davinci_uart_config uart_config __initdata = {
+	.enabled_uarts = (1 << 0),
+};
+static void __init dm368_leopard_map_io(void)
+{
+	/* setup input configuration for VPFE input devices */
+	dm365_set_vpfe_config(&vpfe_cfg);
+	dm365_init();
+}
+
+static __init void dm368_leopard_init(void)
+{
+	leopard_init_i2c();
+	davinci_serial_init(&uart_config);
+
+	dm368leopard_emac_configure();
+	dm368leopard_usb_configure();
+	dm368leopard_mmc_configure();
+
+	dm368leopard_prgb_out_configure();
+
+	davinci_setup_mmc(0, &dm368leopard_mmc_config);
+
+#ifdef CONFIG_SND_DM365_AIC3X_CODEC
+	dm365_init_asp(&dm368_leopard_snd_data);
+	dm368leopard_tlv320aic3x_configure();
+#elif defined(CONFIG_SND_DM365_VOICE_CODEC)
+	dm365_init_vc(&dm368_leopard_snd_data);
+#endif
+	dm365_init_rtc();
+
+	platform_add_devices(dm368_leopard_devices,
+		ARRAY_SIZE(dm368_leopard_devices));
+}
+
+static __init void dm368_leopard_irq_init(void)
+{
+	davinci_irq_init();
+}
+
+MACHINE_START(DM368_LEOPARD, "DM368 Leopard")
+	.boot_params	= (0x80000100),
+	.map_io		= dm368_leopard_map_io,
+	.init_irq	= dm368_leopard_irq_init,
+	.timer		= &davinci_timer,
+	.init_machine	= dm368_leopard_init,
+MACHINE_END
+
Index: kernel/linux-2.6.37-psp03.21.00.04/sound/soc/davinci/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp03.21.00.04/sound/soc/davinci/Kconfig	2014-11-11 08:58:08.000000000 -0700
+++ kernel/linux-2.6.37-psp03.21.00.04/sound/soc/davinci/Kconfig	2015-05-11 11:32:06.717317935 -0600
@@ -16,9 +16,9 @@
 	tristate
 
 config SND_DAVINCI_SOC_EVM
-	tristate "SoC Audio support for DaVinci DM6446, DM355 or DM365 EVM"
+	tristate "SoC Audio support for DaVinci DM6446, DM355, DM368 LEOPARD or DM365 EVM"
 	depends on SND_DAVINCI_SOC
-	depends on MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM || MACH_DAVINCI_DM365_EVM
+	depends on MACH_DM368_LEOPARD || MACH_DAVINCI_EVM || MACH_DAVINCI_DM355_EVM || MACH_DAVINCI_DM365_EVM
 	select SND_DAVINCI_SOC_I2S
 	select SND_SOC_TLV320AIC3X
 	help
